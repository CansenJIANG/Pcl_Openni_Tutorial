<!DOCTYPE html>
<!-- saved from url=(0094)http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic) -->
<html lang="en" dir="ltr" class="client-js"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="UTF-8"><title>PCL/OpenNI tutorial 2: Cloud processing (basic) - Robótica - ULE</title>
<meta name="generator" content="MediaWiki 1.22.5">
<link rel="shortcut icon" href="http://robotica.unileon.es/mediawiki/skins/common/images/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="http://robotica.unileon.es/mediawiki/opensearch_desc.php" title="Robótica - ULE (en)">
<link rel="EditURI" type="application/rsd+xml" href="http://robotica.unileon.es/mediawiki/api.php?action=rsd">
<link rel="alternate" type="application/atom+xml" title="Robótica - ULE Atom feed" href="http://robotica.unileon.es/mediawiki/index.php?title=Special:RecentChanges&feed=atom">
<link rel="stylesheet" href="http://robotica.unileon.es/mediawiki/load.php?debug=false&lang=en&modules=ext.geshi.local%7Cmediawiki.legacy.commonPrint%2Cshared%7Cskins.vector&only=styles&skin=vector&*">
<style>
.mw-collapsible-toggle{float:right} li .mw-collapsible-toggle{float:none} .mw-collapsible-toggle-li{list-style:none}
/* cache key: wikidb:resourceloader:filter:minify-css:7:4250852ed2349a0d4d0fc6509a3e7d4c */
.suggestions{overflow:hidden;position:absolute;top:0;left:0;width:0;border:none;z-index:1099;padding:0;margin:-1px -1px 0 0} html > body .suggestions{margin:-1px 0 0 0}.suggestions-special{position:relative;background-color:white;cursor:pointer;border:solid 1px #aaaaaa;padding:0;margin:0;margin-top:-2px;display:none;padding:0.25em 0.25em;line-height:1.25em}.suggestions-results{background-color:white;cursor:pointer;border:solid 1px #aaaaaa;padding:0;margin:0}.suggestions-result{color:black;margin:0;line-height:1.5em;padding:0.01em 0.25em;text-align:left}.suggestions-result-current{background-color:#4C59A6;color:white}.suggestions-special .special-label{color:gray;text-align:left}.suggestions-special .special-query{color:black;font-style:italic;text-align:left}.suggestions-special .special-hover{background-color:silver}.suggestions-result-current .special-label,.suggestions-result-current .special-query{color:white}.autoellipsis-matched,.highlight{font-weight:bold}
/* cache key: wikidb:resourceloader:filter:minify-css:7:9780324491b653a3780e2d029bdc140c */
.postedit-container{margin:0 auto;position:fixed;top:0;height:0;left:50%;z-index:1000;font-size:13px}.postedit-container:hover{cursor:pointer}.postedit{position:relative;top:0.6em;left:-50%;padding:.6em 3.6em .6em 1.1em;line-height:1.5625em;color:#626465;background-color:#f4f4f4;border:1px solid #dcd9d9;text-shadow:0 0.0625em 0 rgba(255,255,255,0.5);border-radius:5px;-webkit-box-shadow:0 2px 5px 0 #ccc;box-shadow:0 2px 5px 0 #ccc;-webkit-transition:all 0.25s ease-in-out;-moz-transition:all 0.25s ease-in-out;-ms-transition:all 0.25s ease-in-out;-o-transition:all 0.25s ease-in-out;transition:all 0.25s ease-in-out}.skin-monobook .postedit{top:6em !important}.postedit-faded{opacity:0}.postedit-icon{padding-left:41px;  line-height:25px;background-repeat:no-repeat;background-position:8px 50%}.postedit-icon-checkmark{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABblBMVEUAAAD///////9PfTf///80aRdTgjn///9Feij///////////9Rfzf///////////9PfjZRgDh1o1xOfTb///////+bwYqLtnj///////9PfTa82K////9WhT6YxIL///9QgDdTgzr////////j7uDl7eLq8efi693k7OH///////9UhjuBr2rp9uRUhjr///9YljVKgir///9WiTlYjT3////9/v57vFlbkT5PjC9dlD/5/fhuq09stUTs9uhxuElctCpfnT1huDFloEZloUZmpENmvDZpvDxpvTxqvjxrvT5rvT9rwTxsqktswD5uwkBvuUdxw0NztFBztU9ztVBzwkp0tlJ1xkd2t1R3uVR4w1F4xk54x014yE15uVZ5v1R5xVB6v1R7yFJ8wVh9xVl9yFR9yVd9ylN+xVh+yFd/x1l/yFeAylmEx1+Ny2uY0Hqe04Wj1Ymv3Ze33qLD47TJ5L3O6cPU7Mrq9eb2+/Q4j37OAAAAQHRSTlMAAQIEBAUFBQwPFB4fJCUoKiosQEhJS01RUlZZXmdydXaChYuSlJSWmJmoq6uur8LExcvM19fg5ejt8fX2+Pr7SljgewAAAKpJREFUGBkFwQNCAwAAAMDLtl3LtrG4rWXbtvX77gAgZ6grFwC0bhwNVgKgdPZx8b0dgLi+s7Wn0VoAqpfOI9+BNADZI7fLrz2pSEwGHZuH+78lSK8ZLkLezF3ooyUG3VPXq2USei9WngeyoG195yBYWDF3E/2pAhl1e9Gr8bGT+bfOFCC2fnvh4X7rcqIAQNNu+HT6sxkAjceTL/2ZAIhv+PorBwBJxfkA//dFHSCBy/UTAAAAAElFTkSuQmCC);background-image:url(http://robotica.unileon.es/mediawiki/resources/mediawiki.action/images/green-checkmark.png?2014-04-10T08:01:40Z)!ie;background-position:left}.postedit-close{position:absolute;padding:0 .8em;right:0;top:0;font-size:1.25em;font-weight:bold;line-height:2.3em;color:black;text-shadow:0 0.0625em 0 white;text-decoration:none;opacity:0.2;filter:alpha(opacity=20)}.postedit-close:hover{color:black;text-decoration:none;opacity:0.4;filter:alpha(opacity=40)}
/* cache key: wikidb:resourceloader:filter:minify-css:7:9b39df22efb31003b8c266f2194113b0 */</style><style>
.suggestions a.mw-searchSuggest-link,.suggestions a.mw-searchSuggest-link:hover,.suggestions a.mw-searchSuggest-link:active,.suggestions a.mw-searchSuggest-link:focus{text-decoration:none;color:black}.suggestions-result-current a.mw-searchSuggest-link,.suggestions-result-current a.mw-searchSuggest-link:hover,.suggestions-result-current a.mw-searchSuggest-link:active,.suggestions-result-current a.mw-searchSuggest-link:focus{color:white}
/* cache key: wikidb:resourceloader:filter:minify-css:7:52b1797f70c7e4094dfa4191101944e8 */</style><meta name="ResourceLoaderDynamicStyles" content="">
<style>a:lang(ar),a:lang(ckb),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: wikidb:resourceloader:filter:minify-css:7:c2f15db357ed1b34653e004540bd5f70 */</style>

<script src="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/load.php"></script><script src="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/load(1).php"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)","wgTitle":"PCL/OpenNI tutorial 2: Cloud processing (basic)","wgCurRevisionId":4666,"wgRevisionId":4666,"wgArticleId":245,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)","wgIsProbablyEditable":false,"wgRestrictionEdit":["sysop"],"wgRestrictionMove":["sysop"]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"vector-simplesearch":1,"watchcreations":0,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,
"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"useeditwarning":1,"prefershttps":1,"language":"en","variant-gan":"gan","variant-iu":"iu","variant-kk":"kk","variant-ku":"ku","variant-shi":"shi","variant-sr":"sr","variant-tg":"tg","variant-uz":"uz","variant-zh":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"variant":"en"});},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});},{},{});
/* cache key: wikidb:resourceloader:filter:minify-js:7:5a69c7e0fa6557851b6dea8a62efaffb */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script><script src="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/load(2).php"></script>
<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000ff;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #666666;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #000099; font-weight: bold;}
.cpp.source-cpp .es1 {color: #000099; font-weight: bold;}
.cpp.source-cpp .es2 {color: #660099; font-weight: bold;}
.cpp.source-cpp .es3 {color: #660099; font-weight: bold;}
.cpp.source-cpp .es4 {color: #660099; font-weight: bold;}
.cpp.source-cpp .es5 {color: #006699; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #FF0000;}
.cpp.source-cpp .nu0 {color: #0000dd;}
.cpp.source-cpp .nu6 {color: #208080;}
.cpp.source-cpp .nu8 {color: #208080;}
.cpp.source-cpp .nu12 {color: #208080;}
.cpp.source-cpp .nu16 {color:#800080;}
.cpp.source-cpp .nu17 {color:#800080;}
.cpp.source-cpp .nu18 {color:#800080;}
.cpp.source-cpp .nu19 {color:#800080;}
.cpp.source-cpp .me1 {color: #007788;}
.cpp.source-cpp .me2 {color: #007788;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style><style type="text/css">/*<![CDATA[*/
.source-bash {line-height: normal;}
.source-bash li, .source-bash pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for bash
 * CSS class: source-bash, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.bash.source-bash .de1, .bash.source-bash .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.bash.source-bash  {font-family:monospace;}
.bash.source-bash .imp {font-weight: bold; color: red;}
.bash.source-bash li, .bash.source-bash .li1 {font-weight: normal; vertical-align:top;}
.bash.source-bash .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.bash.source-bash .li2 {font-weight: bold; vertical-align:top;}
.bash.source-bash .kw1 {color: #000000; font-weight: bold;}
.bash.source-bash .kw2 {color: #c20cb9; font-weight: bold;}
.bash.source-bash .kw3 {color: #7a0874; font-weight: bold;}
.bash.source-bash .co0 {color: #666666; font-style: italic;}
.bash.source-bash .co1 {color: #800000;}
.bash.source-bash .co2 {color: #cc0000; font-style: italic;}
.bash.source-bash .co3 {color: #000000; font-weight: bold;}
.bash.source-bash .es1 {color: #000099; font-weight: bold;}
.bash.source-bash .es2 {color: #007800;}
.bash.source-bash .es3 {color: #007800;}
.bash.source-bash .es4 {color: #007800;}
.bash.source-bash .es5 {color: #780078;}
.bash.source-bash .es_h {color: #000099; font-weight: bold;}
.bash.source-bash .br0 {color: #7a0874; font-weight: bold;}
.bash.source-bash .sy0 {color: #000000; font-weight: bold;}
.bash.source-bash .st0 {color: #ff0000;}
.bash.source-bash .st_h {color: #ff0000;}
.bash.source-bash .nu0 {color: #000000;}
.bash.source-bash .re0 {color: #007800;}
.bash.source-bash .re1 {color: #007800;}
.bash.source-bash .re2 {color: #007800;}
.bash.source-bash .re4 {color: #007800;}
.bash.source-bash .re5 {color: #660033;}
.bash.source-bash .ln-xtra, .bash.source-bash li.ln-xtra, .bash.source-bash div.ln-xtra {background-color: #ffc;}
.bash.source-bash span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/mediawiki/skins/vector/csshover.min.htc")}</style><![endif]--><script async="" src="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/load(3).php"></script></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-PCL_OpenNI_tutorial_2_Cloud_processing_basic skin-vector action-view vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">PCL/OpenNI tutorial 2: Cloud processing (basic)</span></h1>
			<div id="bodyContent">
								<div id="siteSub">From Robótica - ULE</div>
								<div id="contentSub"></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#mw-navigation">navigation</a>, 					<a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><p>Go to root: <a href="http://robotica.unileon.es/mediawiki/index.php/PhD-3D-Object-Tracking" title="PhD-3D-Object-Tracking">PhD-3D-Object-Tracking</a>
</p>
<hr>
<hr>
<p><br>
</p>
<div class="thumb tright"><div class="thumbinner" style="width:202px;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:Point_cloud.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/Point_cloud.png" width="200" height="116" class="thumbimage"></a>  <div class="thumbcaption"><div class="magnify"><a href="http://robotica.unileon.es/mediawiki/index.php/File:Point_cloud.png" class="internal" title="Enlarge"><img src="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/magnify-clip.png" width="15" height="11" alt=""></a></div>Rendering of a point cloud, showing a desktop.</div></div></div>
<p>All right: in the <a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_1:_Installing_and_testing" title="PCL/OpenNI tutorial 1: Installing and testing"> previous tutorial</a> you installed OpenNI and PCL. You managed to get your device working. You compiled and ran the example program, watched as it fetched one frame after another, and even saved a couple of point clouds to disk. Now you may be wondering "What about now? What use depth sensors are? What can I do with point clouds?"
</p><p>Well, depth cameras have a lot of useful applications. For example, you could use them as <a rel="nofollow" class="external text" href="http://tech.integrate.biz/kinect_mocap.htm">motion tracking</a> hardware and save you thousands of dollars in professional gear. The original Kinect was actually designed as an alternative to physical controllers (e.g., gamepads) in games. <a rel="nofollow" class="external text" href="http://frantracerkinectft.codeplex.com/">Hand gestures</a> can also be recognized, so people have managed to successfully implement control interfaces similar to what could be seen in Minority Report.
</p><p>Working low-level with point clouds offers interesting possibilities too. As they are essentially a 3D "scan" or the scene, you could capture your whole room as a <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/using_kinfu_large_scale.php">continuous 3D mesh</a>, then import it in your modelling software of choice and use it as a reference for a better reconstruction. You could use it to measure distances, or detect obstacles, for a robot navigation system. But the most exciting alternative by far, and the one where most of the research is being focused on, is to perform 3D object recognition and pose estimation, even in <a rel="nofollow" class="external text" href="http://www.youtube.com/watch?feature=player_detailpage&v=quGhaggn3cQ#t=349">real time</a>. This allows a robot to fulfill tasks like going to the kitchen to get you a cup of coffee.
</p><p>Most of the advanced stuff that can be done with a point cloud requires some previous steps, like filtering, reconstruction or normal estimation. In this tutorial, I will introduce you to the basics of point cloud processing, and leave the complicated methods for the <a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)" title="PCL/OpenNI tutorial 3: Cloud processing (advanced)"> next tutorial</a>. I will explain what every technique does and what it should be used for, and include PCL code snippets so you can check how to implement it in your programs.
</p>
<div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2><span class="toctoggle">&nbsp;[<a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#" class="internal" id="togglelink">hide</a>]&nbsp;</span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Point_clouds"><span class="tocnumber">1</span> <span class="toctext">Point clouds</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#PCD_files"><span class="tocnumber">1.1</span> <span class="toctext">PCD files</span></a>
<ul>
<li class="toclevel-3 tocsection-3"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Reading_from_file"><span class="tocnumber">1.1.1</span> <span class="toctext">Reading from file</span></a></li>
<li class="toclevel-3 tocsection-4"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Writing_to_file"><span class="tocnumber">1.1.2</span> <span class="toctext">Writing to file</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-5"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Visualization"><span class="tocnumber">1.2</span> <span class="toctext">Visualization</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Concatenating_two_clouds"><span class="tocnumber">1.3</span> <span class="toctext">Concatenating two clouds</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Matrix_transformations"><span class="tocnumber">1.4</span> <span class="toctext">Matrix transformations</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Using_indices"><span class="tocnumber">1.5</span> <span class="toctext">Using indices</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Removing_NaNs"><span class="tocnumber">1.6</span> <span class="toctext">Removing NaNs</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Saving_a_PNG"><span class="tocnumber">1.7</span> <span class="toctext">Saving a PNG</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Computing_the_centroid"><span class="tocnumber">1.8</span> <span class="toctext">Computing the centroid</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-12"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Feature_estimation"><span class="tocnumber">2</span> <span class="toctext">Feature estimation</span></a>
<ul>
<li class="toclevel-2 tocsection-13"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Normal_estimation"><span class="tocnumber">2.1</span> <span class="toctext">Normal estimation</span></a>
<ul>
<li class="toclevel-3 tocsection-14"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Integral_images"><span class="tocnumber">2.1.1</span> <span class="toctext">Integral images</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-15"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Decomposition"><span class="tocnumber">3</span> <span class="toctext">Decomposition</span></a>
<ul>
<li class="toclevel-2 tocsection-16"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#k-d_tree"><span class="tocnumber">3.1</span> <span class="toctext"><i>k</i>-d tree</span></a>
<ul>
<li class="toclevel-3 tocsection-17"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Searching"><span class="tocnumber">3.1.1</span> <span class="toctext">Searching</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-18"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Octree"><span class="tocnumber">3.2</span> <span class="toctext">Octree</span></a>
<ul>
<li class="toclevel-3 tocsection-19"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Searching_2"><span class="tocnumber">3.2.1</span> <span class="toctext">Searching</span></a></li>
<li class="toclevel-3 tocsection-20"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Compressing.2FDecompressing"><span class="tocnumber">3.2.2</span> <span class="toctext">Compressing/Decompressing</span></a></li>
<li class="toclevel-3 tocsection-21"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Detecting_changes"><span class="tocnumber">3.2.3</span> <span class="toctext">Detecting changes</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-22"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Filtering"><span class="tocnumber">4</span> <span class="toctext">Filtering</span></a>
<ul>
<li class="toclevel-2 tocsection-23"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Passthrough_filter"><span class="tocnumber">4.1</span> <span class="toctext">Passthrough filter</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Conditional_removal"><span class="tocnumber">4.2</span> <span class="toctext">Conditional removal</span></a></li>
<li class="toclevel-2 tocsection-25"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Outlier_removal"><span class="tocnumber">4.3</span> <span class="toctext">Outlier removal</span></a>
<ul>
<li class="toclevel-3 tocsection-26"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Radius-based"><span class="tocnumber">4.3.1</span> <span class="toctext">Radius-based</span></a></li>
<li class="toclevel-3 tocsection-27"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Statistical"><span class="tocnumber">4.3.2</span> <span class="toctext">Statistical</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-28"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Resampling"><span class="tocnumber">4.4</span> <span class="toctext">Resampling</span></a>
<ul>
<li class="toclevel-3 tocsection-29"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Downsampling"><span class="tocnumber">4.4.1</span> <span class="toctext">Downsampling</span></a>
<ul>
<li class="toclevel-4 tocsection-30"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Voxel_grid"><span class="tocnumber">4.4.1.1</span> <span class="toctext">Voxel grid</span></a></li>
<li class="toclevel-4 tocsection-31"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Uniform_sampling"><span class="tocnumber">4.4.1.2</span> <span class="toctext">Uniform sampling</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-32"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Upsampling"><span class="tocnumber">4.4.2</span> <span class="toctext">Upsampling</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-33"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Reconstruction"><span class="tocnumber">5</span> <span class="toctext">Reconstruction</span></a>
<ul>
<li class="toclevel-2 tocsection-34"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Surface_smoothing"><span class="tocnumber">5.1</span> <span class="toctext">Surface smoothing</span></a></li>
</ul>
</li>
</ul>
</div>

<h1><span class="mw-headline" id="Point_clouds">Point clouds</span></h1>
<p>First, a little explanation. A point cloud as taken from a depth sensor consists of a series of points in 3D space, as simple as that. A <span style="color:#FF1493">"pcl::PointCloud&lt;PointT&gt;"</span> object stores the points inside a <span style="color:#FF1493">"std::vector&lt;PointT&gt;"</span> structure. The cloud object exposes some functions that let you get information about them, like the point count. As you can see, the class is templated so you can instantiate it for many types of points. For example, <span style="color:#FF1493">"PointXYZ"</span>, which stores three floats for the X, Y and Z coordinates, and <span style="color:#FF1493">"PointXYZRGB"</span>, which also stores color (texture) information for each point, the kind we would get with Kinect or Xtion RGB-D cameras. A list of <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/adding_custom_ptype.php#what-pointt-types-are-available-in-pcl">point types</a> and a basic description of the <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/basic_structures.php">cloud object</a> are available on PCL's website.
</p><p>Clouds will usually be handled with pointers, as they tend to be large. PCL implements the <span style="color:#FF1493">"boost::shared_ptr"</span> class from <a rel="nofollow" class="external text" href="http://www.boost.org/">Boost C++ libraries</a>, that keeps track of the references to a certain object. Every time you pass a shared pointer and a copy of it is created, a reference counter is automatically increased. When the pointer is destroyed, it is decreased. If the counter ever reaches 0, it means that no one is holding an active reference to the object, and its destructor is called to free memory. This can take a while to get used to, and you will be mixing cloud objects and cloud object pointers until then, but do not worry.
</p>
<h2><span class="mw-headline" id="PCD_files">PCD files</span></h2>
<p>When clouds are saved to disk, a <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/pcd_file_format.php">PCD</a> (Point Cloud Data) file is produced. You can choose to do it so in binary or plain text format. The first one is faster to work with, whereas the second one will let you to inspect the cloud by opening it with a common text editor. If you do so, you may see something like this:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2"># .PCD v.7 − Point Cloud Data file format</span>
VERSION .7
FIELDS x y z
SIZE <span class="nu0">4</span> <span class="nu0">4</span> <span class="nu0">4</span>
TYPE F F F
WIDTH <span class="nu0">2</span>
HEIGHT <span class="nu0">1</span>
VIEWPOINT <span class="nu0">0</span> <span class="nu0">0</span> <span class="nu0">0</span> <span class="nu0">1</span> <span class="nu0">0</span> <span class="nu0">0</span> <span class="nu0">0</span>
POINTS <span class="nu0">2</span>
DATA ascii
<span class="nu16">0.73412</span> <span class="sy2">-</span><span class="nu16">1.12643</span> <span class="nu16">0.82218</span>
<span class="nu16">0.44739</span> <span class="sy2">-</span><span class="nu16">0.34735</span> <span class="sy2">-</span><span class="nu16">0.04624</span></pre></div></div>
<p>This tells us that the cloud consist of 2 points of type <span style="color:#FF1493">"PointXYZ"</span> (because each point has only 3 fields; the X, Y and Z coordinates, each stored in a 4-byte float), and lists their coordinates. It also stores the viewport information (the relative position of the points to the sensor) as a translation quaternion. Knowing the position of the camera can be useful for certain procedures like normal estimation.
</p>
<h3><span class="mw-headline" id="Reading_from_file">Reading from file</span></h3>
<p>Reading a point cloud from a PCD file to and storing it in memory can be done with a single function call. You must specify the correct point type. For example, for .pcd files saved with the OpenNI viewer application that we saw in the <a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_1:_Installing_and_testing" title="PCL/OpenNI tutorial 1: Installing and testing"> previous tutorial</a>, you could use either <span style="color:#FF1493">"PointXYZRGBA"</span> or <span style="color:#FF1493">"PointXYZ"</span> if you are not going to use the color information.
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Object for storing the point cloud.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>I have not bothered to include proper error/argument checking, but you should do it in your programs. Be sure to check the <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/">PCL API</a> every time I introduce you to one of its classes or methods.
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/reading_pcd.php">Reading Point Cloud data from PCD files</a>
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/namespacepcl_1_1io.html">pcl::io namespace</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_file_read.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h3><span class="mw-headline" id="Writing_to_file">Writing to file</span></h3>
<p>Saving a point cloud to a file is as easy as reading it. You can choose between doing it in plain readable (ASCII) or binary format. The first one can be read and altered with a text editor, the second one is faster.
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Object for storing the point cloud.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Write it back to disk under a different name.</span>
	<span class="co1">// Another possibility would be "savePCDFileBinary()".</span>
	pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">savePCDFileASCII</span><span class="br0">(</span><span class="st0">"output.pcd"</span>, <span class="sy2">*</span>cloud<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/writing_pcd.php">Writing Point Cloud data to PCD files</a>
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/namespacepcl_1_1io.html">pcl::io namespace</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_file_write.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
If you want a better alternative for loading or saving PCD files (some of the functions we saw are a bit outdated, but they do the job), take a look at the <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_p_c_d_reader.html">PCDReader</a> and <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_p_c_d_writer.html">PCDWriter</a> classes.
</p>
<h2><span class="mw-headline" id="Visualization">Visualization</span></h2>
<p>Of course, PCL ships with a dedicated program to load and visualize point clouds and a lot of other stuff, <span style="color:#228B22"><i>pcl_viewer</i></span>. You can run it from a terminal with:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="bash source-bash" style="font-family:monospace;"><pre class="de1">pcl_viewer <span class="sy0">&lt;</span><span class="kw2">file</span> 1<span class="sy0">&gt;</span> <span class="br0">[</span><span class="kw2">file</span> 2<span class="br0">]</span> ... <span class="br0">[</span><span class="kw2">file</span> N<span class="br0">]</span></pre></div></div>
<p>If you load several files, each cloud will be rendered with a different color to help you tell them apart. The program uses internally the <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1visualization_1_1_p_c_l_visualizer.html">pcl::visualization::PCLVisualizer</a> class. Press the <span style="color:#228B22"><b>H</b></span> key while it is running to print the help on the terminal. Keys I tend to find useful are <span style="color:#228B22"><b>1</b></span>, which chooses a different color for the cloud (useful if the current one is too hard to see), <span style="color:#228B22"><b>R</b></span>, which resets the camera, and <span style="color:#228B22"><b>J</b></span>, which saves a PNG snapshot.
</p><p>In your own code, it is possible to iterate through the cloud and print the information of each point to console, but this is cumbersome. Sometimes you just want to visualize the cloud to check something. PCL can create a window for you and display it, letting users pan and zoom their way around. The simplest method is the following one:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/visualization/cloud_viewer.h&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Object for storing the point cloud.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Cloud viewer object. You can set the window title.</span>
	pcl<span class="sy4">::</span><span class="me2">visualization</span><span class="sy4">::</span><span class="me2">CloudViewer</span> viewer<span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
	viewer.<span class="me1">showCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span>viewer.<span class="me1">wasStopped</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
	<span class="br0">{</span>
		<span class="co1">// Do nothing but wait.</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p><span style="color:#FF1493">"CloudViewer"</span> has less features than <span style="color:#FF1493">"PCLVisualizer"</span> but it is easier to set up. The program will remain active until you close the window with <span style="color:#228B22"><b>Alt+F4</b></span> or press <span style="color:#228B22"><b>Q</b></span>.
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Tutorials</b>:
<ul>
<li> <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/cloud_viewer.php">The CloudViewer</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/pcl_visualizer.php">PCLVisualizer</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/walkthrough.php">Visualization library overview</a>
</li>
</ul>
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1visualization_1_1_cloud_viewer.html">pcl::visualization::CloudViewer</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_visualize_cloud.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h2><span class="mw-headline" id="Concatenating_two_clouds">Concatenating two clouds</span></h2>
<p>There are two types of concatenation with point clouds:
</p>
<ul>
<li> <b>Points</b>:  You initially have two clouds, "A" and "B", with "N" and "M" points each. A third cloud is created ("C"), that has "N + M" points (all points of the first two clouds). For this to work, the point type must be the same for all clouds (<span style="color:#FF1493">"PointXYZ"</span>, or <span style="color:#FF1493">"Normal"</span>, or whatever).
</li>
<li> <b>Fields</b>: With this, you can join the fields of two clouds with different types. The only constraint is that both must have the same number of points. For example, if you have a cloud of the <span style="color:#FF1493">"PointXYZ"</span> type and another of <span style="color:#FF1493">"Normal"</span> type with "N" points each, you can concatenate them to create a cloud of type <span style="color:#FF1493">"PointNormal"</span> (that stores X, Y and Z coordinates, plus the normal) that also has "N" points.
</li>
</ul>
<p>Point concatenation is the easiest one becase you can use the cloud's add operator (+), which is overloaded.
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Objects for storing the point clouds.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZRGBA</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloudA<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZRGBA</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZRGBA</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloudB<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZRGBA</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZRGBA</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloudC<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZRGBA</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read two PCD files from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZRGBA</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloudA<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZRGBA</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>2<span class="br0">]</span>, <span class="sy2">*</span>cloudB<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Create cloud "C", with the points of both "A" and "B".</span>
	<span class="sy2">*</span>cloudC <span class="sy1">=</span> <span class="br0">(</span><span class="sy2">*</span>cloudA<span class="br0">)</span> <span class="sy2">+</span> <span class="br0">(</span><span class="sy2">*</span>cloudB<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Now cloudC-&gt;points.size() equals cloudA-&gt;points.size() + cloudB-&gt;points.size().</span>
<span class="br0">}</span></pre></div></div>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/concatenate_clouds.php">Concatenate the points of two Point Clouds</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_concatenate_clouds.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
Field concatenation is done with a function call:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/features/normal_3d.h&gt;</span>
&nbsp;
<span class="co2">#include &lt;iostream&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Objects for storing the point clouds.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloudPoints<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">Normal</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloudNormals<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">Normal</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointNormal</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloudAll<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointNormal</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloudPoints<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Compute the normals of the cloud (do not worry, we will see this later).</span>
	pcl<span class="sy4">::</span><span class="me2">NormalEstimation</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span>, pcl<span class="sy4">::</span><span class="me2">Normal</span><span class="sy1">&gt;</span> normalEstimation<span class="sy4">;</span>
	normalEstimation.<span class="me1">setInputCloud</span><span class="br0">(</span>cloudPoints<span class="br0">)</span><span class="sy4">;</span>
	normalEstimation.<span class="me1">setRadiusSearch</span><span class="br0">(</span>0.05<span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">search</span><span class="sy4">::</span><span class="me2">KdTree</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> kdtree<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">search</span><span class="sy4">::</span><span class="me2">KdTree</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	normalEstimation.<span class="me1">setSearchMethod</span><span class="br0">(</span>kdtree<span class="br0">)</span><span class="sy4">;</span>
	normalEstimation.<span class="me1">compute</span><span class="br0">(</span><span class="sy2">*</span>cloudNormals<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Concatenate the fields (PointXYZ + Normal = PointNormal).</span>
	pcl<span class="sy4">::</span><span class="me2">concatenateFields</span><span class="br0">(</span><span class="sy2">*</span>cloudPoints, <span class="sy2">*</span>cloudNormals, <span class="sy2">*</span>cloudAll<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Print the data to standard output.</span>
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">size_t</span> currentPoint <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> currentPoint <span class="sy1">&lt;</span> cloudAll<span class="sy2">-</span><span class="sy1">&gt;</span>points.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> currentPoint<span class="sy2">++</span><span class="br0">)</span>
	<span class="br0">{</span>
		std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"Point:"</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
		std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"<span class="es1">\t</span>XYZ:"</span> <span class="sy1">&lt;&lt;</span> cloudAll<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span>currentPoint<span class="br0">]</span>.<span class="me1">x</span> <span class="sy1">&lt;&lt;</span> <span class="st0">" "</span>
				  <span class="sy1">&lt;&lt;</span> cloudAll<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span>currentPoint<span class="br0">]</span>.<span class="me1">y</span> <span class="sy1">&lt;&lt;</span> <span class="st0">" "</span>
				  <span class="sy1">&lt;&lt;</span> cloudAll<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span>currentPoint<span class="br0">]</span>.<span class="me1">z</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
		std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"<span class="es1">\t</span>Normal:"</span> <span class="sy1">&lt;&lt;</span> cloudAll<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span>currentPoint<span class="br0">]</span>.<span class="me1">normal</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy1">&lt;&lt;</span> <span class="st0">" "</span>
				  <span class="sy1">&lt;&lt;</span> cloudAll<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span>currentPoint<span class="br0">]</span>.<span class="me1">normal</span><span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy1">&lt;&lt;</span> <span class="st0">" "</span>
				  <span class="sy1">&lt;&lt;</span> cloudAll<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span>currentPoint<span class="br0">]</span>.<span class="me1">normal</span><span class="br0">[</span>2<span class="br0">]</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/concatenate_clouds.php">Concatenate the points of two Point Clouds</a>
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/group__common.html#gac6add803f86fd16a998dce541e9ef402">pcl::concatenateFields()</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_concatenate_fields.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h2><span class="mw-headline" id="Matrix_transformations">Matrix transformations</span></h2>
<p>Clouds can be directly manipulated with <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Transformation_matrix">transformations</a> (translation, rotation, scaling). 3D transformations use a 4x4 matrix, which can be a little complicated to understand (specially when it comes to rotations), so check some book or <a rel="nofollow" class="external text" href="http://web.iitd.ac.in/~hegde/cad/lecture/L6_3dtrans.pdf">tutorial</a> before trying to use one. The transformed cloud will be saved to another object so you can keep both versions and use them as you wish.
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/common/transforms.h&gt;</span>
<span class="co2">#include &lt;pcl/visualization/pcl_visualizer.h&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Objects for storing the point clouds.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> transformed<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Transformation matrix object, initialized to the identity matrix</span>
	<span class="co1">// (a null transformation).</span>
	Eigen<span class="sy4">::</span><span class="me2">Matrix4f</span> transformation <span class="sy1">=</span> Eigen<span class="sy4">::</span><span class="me2">Matrix4f</span><span class="sy4">::</span><span class="me2">Identity</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Set a rotation around the Z axis.</span>
	<span class="kw4">float</span> theta <span class="sy1">=</span> M_PI <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span> <span class="co1">// 180 degrees.</span>
	transformation<span class="br0">(</span>0, 0<span class="br0">)</span> <span class="sy1">=</span> <span class="kw3">cos</span><span class="br0">(</span>theta<span class="br0">)</span><span class="sy4">;</span>
	transformation<span class="br0">(</span>0, 1<span class="br0">)</span> <span class="sy1">=</span> <span class="sy2">-</span><span class="kw3">sin</span><span class="br0">(</span>theta<span class="br0">)</span><span class="sy4">;</span>
	transformation<span class="br0">(</span>1, 0<span class="br0">)</span> <span class="sy1">=</span> <span class="kw3">sin</span><span class="br0">(</span>theta<span class="br0">)</span><span class="sy4">;</span>
	transformation<span class="br0">(</span>1, 1<span class="br0">)</span> <span class="sy1">=</span> <span class="kw3">cos</span><span class="br0">(</span>theta<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Set a translation on the X axis.</span>
	transformation<span class="br0">(</span>0, 3<span class="br0">)</span> <span class="sy1">=</span> <span class="nu17">1.0f</span><span class="sy4">;</span> <span class="co1">// 1 meter (positive direction).</span>
&nbsp;
	pcl<span class="sy4">::</span><span class="me2">transformPointCloud</span><span class="br0">(</span><span class="sy2">*</span>cloud, <span class="sy2">*</span>transformed, transformation<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Visualize both the original and the result.</span>
	pcl<span class="sy4">::</span><span class="me2">visualization</span><span class="sy4">::</span><span class="me2">PCLVisualizer</span> viewer<span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
	viewer.<span class="me1">addPointCloud</span><span class="br0">(</span>cloud, <span class="st0">"original"</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// The transformed one's points will be red in color.</span>
	pcl<span class="sy4">::</span><span class="me2">visualization</span><span class="sy4">::</span><span class="me2">PointCloudColorHandlerCustom</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> colorHandler<span class="br0">(</span>transformed, 255, 0, 0<span class="br0">)</span><span class="sy4">;</span>
	viewer.<span class="me1">addPointCloud</span><span class="br0">(</span>transformed, colorHandler, <span class="st0">"transformed"</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Add 3D colored axes to help see the transformation.</span>
	viewer.<span class="me1">addCoordinateSystem</span><span class="br0">(</span><span class="nu16">1.0</span>, <span class="st0">"reference"</span>, 0<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span>viewer.<span class="me1">wasStopped</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
	<span class="br0">{</span>
		viewer.<span class="me1">spinOnce</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p><br>
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:602px;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:Cloud_transformation.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/Cloud_transformation.png" width="600" height="366" class="thumbimage"></a>  <div class="thumbcaption"><div class="magnify"><a href="http://robotica.unileon.es/mediawiki/index.php/File:Cloud_transformation.png" class="internal" title="Enlarge"><img src="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/magnify-clip.png" width="15" height="11" alt=""></a></div>Rotation and translation applied to a cloud.</div></div></div></div>
<p><br>
Check the rest of the functions, because you can also use a <span style="color:#FF1493">"Eigen::Affine3"</span> or a <span style="color:#FF1493">"Eigen::Quaternion"</span> instead of a <span style="color:#FF1493">"Eigen::Matrix4"</span> object.
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Transformation
</li>
<li> <b>Output</b>: Transformed points
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/matrix_transform.php">Using a matrix to transform a point cloud</a>
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/namespacepcl.html#aefbe4956d1c8fb785a97df6708d57c56">pcl::transformPointCloud()</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_matrix_transform.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h2><span class="mw-headline" id="Using_indices">Using indices</span></h2>
<p>Many of PCL's algorithms return indices. Indices are just a list of some of the points of a cloud (not the points themselves with all their data, but just their index in the cloud). For example, a cylinder segmentation algorithm will give you as output a list of points that were considered to fit the cylinder model. You can then use the indices to extract the points to a second cloud for further work with the <span style="color:#FF1493">"pcl::ExtractIndices"</span> class. Its <span style="color:#FF1493">"setNegative()"</span> function will instruct it to extract the points NOT indexed (so you can remove all cylinder-shaped clusters from the cloud).
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/filters/extract_indices.h&gt;</span>
<span class="co2">#include &lt;pcl/segmentation/sac_segmentation.h&gt;</span>
&nbsp;
<span class="co2">#include &lt;vector&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Objects for storing the point clouds.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloudAll<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloudExtracted<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloudAll<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Plane segmentation (do not worry, we will see this later).</span>
	pcl<span class="sy4">::</span><span class="me2">ModelCoefficients</span><span class="sy4">::</span><span class="me2">Ptr</span> coefficients<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">ModelCoefficients</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">SACSegmentation</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> segmentation<span class="sy4">;</span>
	segmentation.<span class="me1">setOptimizeCoefficients</span><span class="br0">(</span><span class="kw2">true</span><span class="br0">)</span><span class="sy4">;</span>
	segmentation.<span class="me1">setModelType</span><span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">SACMODEL_PLANE</span><span class="br0">)</span><span class="sy4">;</span>
	segmentation.<span class="me1">setMethodType</span><span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">SAC_RANSAC</span><span class="br0">)</span><span class="sy4">;</span>
	segmentation.<span class="me1">setDistanceThreshold</span><span class="br0">(</span>0.01<span class="br0">)</span><span class="sy4">;</span>
	segmentation.<span class="me1">setInputCloud</span><span class="br0">(</span>cloudAll<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Object for storing the indices.</span>
	pcl<span class="sy4">::</span><span class="me2">PointIndices</span><span class="sy4">::</span><span class="me2">Ptr</span> pointIndices<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointIndices</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	segmentation.<span class="me1">segment</span><span class="br0">(</span><span class="sy2">*</span>pointIndices, <span class="sy2">*</span>coefficients<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Object for extracting points from a list of indices.</span>
	pcl<span class="sy4">::</span><span class="me2">ExtractIndices</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> extract<span class="sy4">;</span>
	extract.<span class="me1">setInputCloud</span><span class="br0">(</span>cloudAll<span class="br0">)</span><span class="sy4">;</span>
	extract.<span class="me1">setIndices</span><span class="br0">(</span>pointIndices<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// We will extract the points that are NOT indexed (the ones that are not in a plane).</span>
	extract.<span class="me1">setNegative</span><span class="br0">(</span><span class="kw2">true</span><span class="br0">)</span><span class="sy4">;</span>
	extract.<span class="me1">filter</span><span class="br0">(</span><span class="sy2">*</span>cloudExtracted<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Indices, [Negative mode]
</li>
<li> <b>Output</b>: Points
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/extract_indices.php">Extracting indices from a PointCloud</a>
</li>
<li> <b>API</b>:
<ul>
<li> <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/structpcl_1_1_point_indices.html">pcl::PointIndices</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_extract_indices.html">pcl::ExtractIndices</a>
</li>
</ul>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_extract_indices.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h2><span class="mw-headline" id="Removing_NaNs">Removing NaNs</span></h2>
<p>The cloud retrieved from the sensor may contain several kind of measurement errors and/or inaccuracies. One of them is the presence of <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/NaN">NaN (Not a Number)</a> values in the coordinates of some points, as you can see in the following file:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2"># .PCD v0.7 - Point Cloud Data file format</span>
VERSION 0.7
FIELDS x y z rgba
SIZE <span class="nu0">4</span> <span class="nu0">4</span> <span class="nu0">4</span> <span class="nu0">4</span>
TYPE F F F U
COUNT <span class="nu0">1</span> <span class="nu0">1</span> <span class="nu0">1</span> <span class="nu0">1</span>
WIDTH <span class="nu0">640</span>
HEIGHT <span class="nu0">480</span>
VIEWPOINT <span class="nu0">0</span> <span class="nu0">0</span> <span class="nu0">0</span> <span class="nu0">1</span> <span class="nu0">0</span> <span class="nu0">0</span> <span class="nu0">0</span>
POINTS <span class="nu0">307200</span>
DATA ascii
nan nan nan <span class="nu0">10135463</span>
nan nan nan <span class="nu0">10398635</span>
nan nan nan <span class="nu0">10070692</span>
nan nan nan <span class="nu0">10268071</span>
...</pre></div></div>
<p>Cloud objects have a member function called <span style="color:#FF1493">"is_dense()"</span> that will return true if all points have valid, finite values. A NaN indicates that there was a problem measuring the distance to that point, maybe because the sensor was too close or too far, or because the surface was reflective.
</p><p>Sadly, many of PCL's algorithms will fail if even a single NaN is present in the cloud you feed them as input, with a message like <span style="color:#FF1493"><i>"Assertion `point_representation_-&gt;isValid (point) &amp;&amp; "Invalid (NaN, Inf) point coordinates given to radiusSearch!"' failed."</i></span>. If this happens, you will have to remove such values from the cloud. You can use a program like the following to "clean" a cloud from all NaN points:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/filters/filter.h&gt;</span>
&nbsp;
<span class="co2">#include &lt;iostream&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>argc <span class="sy3">!</span><span class="sy1">=</span> 3<span class="br0">)</span>
	<span class="br0">{</span>
		std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"<span class="es1">\t</span>Usage: "</span> <span class="sy1">&lt;&lt;</span> argv<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy1">&lt;&lt;</span> <span class="st0">" &lt;input cloud&gt; &lt;output cloud&gt;"</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
&nbsp;
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Object for storing the point cloud.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// The mapping tells you to what points of the old cloud the new ones correspond,</span>
	<span class="co1">// but we will not use it.</span>
	std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> mapping<span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">removeNaNFromPointCloud</span><span class="br0">(</span><span class="sy2">*</span>cloud, <span class="sy2">*</span>cloud, mapping<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Save it back.</span>
	pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">savePCDFileASCII</span><span class="br0">(</span>argv<span class="br0">[</span>2<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>The problem with this method is that it will not keep the cloud organized. All clouds store a <span style="color:#FF1493">"width"</span> and a <span style="color:#FF1493">"height"</span> variable. In <i>unorganized</i> clouds, the total number of points is the same as the width, and the height is set to 1. In <i>organized</i> clouds (like the ones taken from camera-like sensors such as Kinect or Xtion), the width and the height are the same that the pixels of the image resolution the sensor works with. Points are distributed in rows like in the depth image, and every one of them corresponds to a pixel. The member function <span style="color:#FF1493">"isOrganized()"</span> will return true if the height is greater than 1.
</p><p>Because removing NaNs will change the number of points of the cloud, it can no longer be kept organized with the original width/height ratio, so the function will set the height to 1. This is not a big issue, as only a few of PCL's algorithms work explicitly with organized clouds (and they mostly use it for optimization), but you must take it into account.
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Cloud
</li>
<li> <b>Output</b>: Cloud without NaNs
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/group__filters.html#gac463283a9e9c18a66d3d29b28a575064">pcl::removeNaNFromPointCloud()</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_remove_NaNs.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h2><span class="mw-headline" id="Saving_a_PNG">Saving a PNG</span></h2>
<p>PCL offers the possibility of saving the values of a point cloud to a PNG image file. Obviously, this can only be done with organized clouds, because the rows and columns of the resulting image will correspond exactly to the ones of the cloud. For example, if you have a point cloud taken from a sensor like Kinect or Xtion, you can use this to retrieve the 640x480 RGB image that matches the cloud.
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/io/png_io.h&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Object for storing the point cloud.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZRGB</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZRGB</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZRGB</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Save the image (cloud must be organized).</span>
	pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">savePNGFile</span><span class="br0">(</span><span class="st0">"output.png"</span>, <span class="sy2">*</span>cloud, <span class="st0">"rgb"</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>The function <span style="color:#FF1493">"savePNGFile()"</span> has several implementations; in this case, we have chosen the one that lets you specify which fields to save. If you omit that parameter, the function will save the RGB fields by default.
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/group__io.html#gabd03e43fac3048635512f447c8bc50b3">pcl::io::savePNGFile()</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_save_PNG.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h2><span class="mw-headline" id="Computing_the_centroid">Computing the centroid</span></h2>
<p>The <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Centroid">centroid</a> of a cloud is a point with coordinates that result from computing the mean of the values of all points in the cloud. You could say it is the "center of mass", and it has several uses for certain algorithms. If you intend to compute the actual center of gravity of a <a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#Segmentation" title="PCL/OpenNI tutorial 3: Cloud processing (advanced)">clustered</a> object though, remember that the sensor does not retrieve the part of the object that is hidden from the camera, like the back faces that are occluded by the front ones, or the inside. You only have the part of the surface that faces the camera.
</p><p>The centroid of a cloud can be computed with a single function call:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/common/centroid.h&gt;</span>
&nbsp;
<span class="co2">#include &lt;iostream&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Object for storing the point cloud.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Object to store the centroid coordinates.</span>
	Eigen<span class="sy4">::</span><span class="me2">Vector4f</span> centroid<span class="sy4">;</span>
&nbsp;
	pcl<span class="sy4">::</span><span class="me2">compute3DCentroid</span><span class="br0">(</span><span class="sy2">*</span>cloud, centroid<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"The XYZ coordinates of the centroid are: ("</span>
			  <span class="sy1">&lt;&lt;</span> centroid<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy1">&lt;&lt;</span> <span class="st0">", "</span>
			  <span class="sy1">&lt;&lt;</span> centroid<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy1">&lt;&lt;</span> <span class="st0">", "</span>
			  <span class="sy1">&lt;&lt;</span> centroid<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy1">&lt;&lt;</span> <span class="st0">")."</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/namespacepcl.html#a23daec3829d2d4100a2f185372b3753a">pcl::compute3DCentroid()</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_compute_centroid.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h1><span class="mw-headline" id="Feature_estimation">Feature estimation</span></h1>
<p>A <i>feature</i> of a point is some characteristic that can help us to tell it apart from a different point. Of course, you could say that the XYZ coordinates would be characteristic enough, but when interpolating the data of two different, yet corresponding, clouds, they become useless. We need something better, that will have similar values when computed for the same spot of a surface in both sets.
</p><p>Normals are an example of a very simple feature. 3D <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/how_features_work.php">features</a> will be important later in our tutorials, when we talk about <a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_4:_3D_object_recognition_(descriptors)" title="PCL/OpenNI tutorial 4: 3D object recognition (descriptors)">descriptors</a> (more detailed "signatures" of points used for close matching).
</p>
<h2><span class="mw-headline" id="Normal_estimation">Normal estimation</span></h2>
<p>As you may remember from geometry class, the <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Surface_normal">normal</a> of a plane is an unit vector that is perpendicular to it. The normal of a surface at a point is defined as the vector that is perpendicular to the plane that is tangent to the surface at the point. Surface normals can be calculated for the points of a cloud, too. It is considered a feature, albeit not a very discriminative one.
</p><p>I will not go into detail with the math of the estimation method, but you just have to know that is uses the nearest neighbors (the points that are closest to the one we are calculating the normal for) to find out the tangent plane and the normal vector. You can customize the method with the search radius (think about a sphere of that radius, centered in the point; all neighboring points that lie within will be used for the computation) and the viewpoint (by default, the output normals will be directionless; by supposing that all vectors must point towards the camera - because otherwise they would belong to surfaces that are not visible from the sensor - they can all be re-oriented accordingly).
</p><p>Normals are also important because they give us information about the <i>curvature</i> of the surface at some point, which can be used to our advantage. Many of PCL's algorithms will require us to provide the normals of the input cloud. To estimate them, you can use the following code:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/features/normal_3d.h&gt;</span>
<span class="co2">#include &lt;boost/thread/thread.hpp&gt;</span>
<span class="co2">#include &lt;pcl/visualization/pcl_visualizer.h&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Object for storing the point cloud.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Object for storing the normals.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">Normal</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> normals<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">Normal</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Object for normal estimation.</span>
	pcl<span class="sy4">::</span><span class="me2">NormalEstimation</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span>, pcl<span class="sy4">::</span><span class="me2">Normal</span><span class="sy1">&gt;</span> normalEstimation<span class="sy4">;</span>
	normalEstimation.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// For every point, use all neighbors in a radius of 3cm.</span>
	normalEstimation.<span class="me1">setRadiusSearch</span><span class="br0">(</span>0.03<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// A kd-tree is a data structure that makes searches efficient. More about it later.</span>
	<span class="co1">// The normal estimation object will use it to find nearest neighbors.</span>
	pcl<span class="sy4">::</span><span class="me2">search</span><span class="sy4">::</span><span class="me2">KdTree</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> kdtree<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">search</span><span class="sy4">::</span><span class="me2">KdTree</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	normalEstimation.<span class="me1">setSearchMethod</span><span class="br0">(</span>kdtree<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Calculate the normals.</span>
	normalEstimation.<span class="me1">compute</span><span class="br0">(</span><span class="sy2">*</span>normals<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Visualize them.</span>
	boost<span class="sy4">::</span><span class="me2">shared_ptr</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">visualization</span><span class="sy4">::</span><span class="me2">PCLVisualizer</span><span class="sy1">&gt;</span> viewer<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">visualization</span><span class="sy4">::</span><span class="me2">PCLVisualizer</span><span class="br0">(</span><span class="st0">"Normals"</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
	viewer<span class="sy2">-</span><span class="sy1">&gt;</span>addPointCloud<span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>cloud, <span class="st0">"cloud"</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Display one normal out of 20, as a line of length 3cm.</span>
	viewer<span class="sy2">-</span><span class="sy1">&gt;</span>addPointCloudNormals<span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span>, pcl<span class="sy4">::</span><span class="me2">Normal</span><span class="sy1">&gt;</span><span class="br0">(</span>cloud, normals, <span class="nu0">20</span>, <span class="nu16">0.03</span>, <span class="st0">"normals"</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span>viewer<span class="sy2">-</span><span class="sy1">&gt;</span>wasStopped<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
	<span class="br0">{</span>
		viewer<span class="sy2">-</span><span class="sy1">&gt;</span>spinOnce<span class="br0">(</span>100<span class="br0">)</span><span class="sy4">;</span>
		boost<span class="sy4">::</span><span class="me2">this_thread</span><span class="sy4">::</span><span class="me2">sleep</span><span class="br0">(</span>boost<span class="sy4">::</span><span class="me2">posix_time</span><span class="sy4">::</span><span class="me2">microseconds</span><span class="br0">(</span>100000<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>As you can see, normals are stored in <span style="color:#FF1493">"PointCloud"</span> objects too, instantiated to the <span style="color:#FF1493">"Normal"</span> type. If you ever extract some indices from a cloud before feeding them to an algorithm, be sure to do the same with the normals. I have not made use of the <span style="color:#FF1493">"setViewPoint()"</span> function, but you get the idea.
</p><p>Instead of <span style="color:#FF1493">"setRadiusSearch()"</span>, you can make use of <span style="color:#FF1493">"setKSearch()"</span>, which takes an integer, <i>K</i>. This will take into account a point's <i>K</i> nearest neighbors to compute the normal. Please mind that this can produce some odd results for points that are not in dense areas, as some of the "neighbors" will be too far from them.
</p><p><br>
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:602px;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:Normal_estimation.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/Normal_estimation.png" width="600" height="344" class="thumbimage"></a>  <div class="thumbcaption"><div class="magnify"><a href="http://robotica.unileon.es/mediawiki/index.php/File:Normal_estimation.png" class="internal" title="Enlarge"><img src="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/magnify-clip.png" width="15" height="11" alt=""></a></div>Visualization of the normals computed for a point cloud.</div></div></div></div>
<p><br>
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Search method, Radius | Neighbor count, [Indices], [Viewpoint]
</li>
<li> <b>Output</b>: Normals
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/normal_estimation.php">Estimating Surface Normals in a Point Cloud</a>
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_normal_estimation.html">pcl::NormalEstimation</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_estimate_normals.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h3><span class="mw-headline" id="Integral_images">Integral images</span></h3>
<p>Integral images are a method for normal estimation on organized clouds. The algorithm sees the cloud as a depth image, and creates certain rectangular areas over which the normals are computed, by taking into account the relationship between neighboring "pixels" (points), without the need to run lookups on a search structure like a tree. Because of this, it is very efficient and the normals are usually computed in a split second. If you are performing real time computations on clouds taken from a RGB-D sensor, this is the approach you should use because the previous method will probably take several seconds to finish.
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/features/integral_image_normal.h&gt;</span>
<span class="co2">#include &lt;boost/thread/thread.hpp&gt;</span>
<span class="co2">#include &lt;pcl/visualization/pcl_visualizer.h&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Object for storing the point cloud.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Object for storing the normals.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">Normal</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> normals<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">Normal</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Object for normal estimation.</span>
	pcl<span class="sy4">::</span><span class="me2">IntegralImageNormalEstimation</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span>, pcl<span class="sy4">::</span><span class="me2">Normal</span><span class="sy1">&gt;</span> normalEstimation<span class="sy4">;</span>
	normalEstimation.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Other estimation methods: COVARIANCE_MATRIX, AVERAGE_DEPTH_CHANGE, SIMPLE_3D_GRADIENT.</span>
	<span class="co1">// They determine the smoothness of the result, and the running time.</span>
	normalEstimation.<span class="me1">setNormalEstimationMethod</span><span class="br0">(</span>normalEstimation.<span class="me1">AVERAGE_3D_GRADIENT</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Depth threshold for computing object borders based on depth changes, in meters.</span>
	normalEstimation.<span class="me1">setMaxDepthChangeFactor</span><span class="br0">(</span>0.02f<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Factor that influences the size of the area used to smooth the normals.</span>
	normalEstimation.<span class="me1">setNormalSmoothingSize</span><span class="br0">(</span>10.0f<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Calculate the normals.</span>
	normalEstimation.<span class="me1">compute</span><span class="br0">(</span><span class="sy2">*</span>normals<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Visualize them.</span>
	boost<span class="sy4">::</span><span class="me2">shared_ptr</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">visualization</span><span class="sy4">::</span><span class="me2">PCLVisualizer</span><span class="sy1">&gt;</span> viewer<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">visualization</span><span class="sy4">::</span><span class="me2">PCLVisualizer</span><span class="br0">(</span><span class="st0">"Normals"</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
	viewer<span class="sy2">-</span><span class="sy1">&gt;</span>addPointCloud<span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>cloud, <span class="st0">"cloud"</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Display one normal out of 20, as a line of length 3cm.</span>
	viewer<span class="sy2">-</span><span class="sy1">&gt;</span>addPointCloudNormals<span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span>, pcl<span class="sy4">::</span><span class="me2">Normal</span><span class="sy1">&gt;</span><span class="br0">(</span>cloud, normals, <span class="nu0">20</span>, <span class="nu16">0.03</span>, <span class="st0">"normals"</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span>viewer<span class="sy2">-</span><span class="sy1">&gt;</span>wasStopped<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
	<span class="br0">{</span>
		viewer<span class="sy2">-</span><span class="sy1">&gt;</span>spinOnce<span class="br0">(</span>100<span class="br0">)</span><span class="sy4">;</span>
		boost<span class="sy4">::</span><span class="me2">this_thread</span><span class="sy4">::</span><span class="me2">sleep</span><span class="br0">(</span>boost<span class="sy4">::</span><span class="me2">posix_time</span><span class="sy4">::</span><span class="me2">microseconds</span><span class="br0">(</span>100000<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Estimation method, [Smoothing factor], [Depth threshold], [Rectangle size], [Border policy], [Depth dependent smoothing]
</li>
<li> <b>Output</b>: Normals
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/normal_estimation_using_integral_images.php">Normal Estimation Using Integral Images</a>
</li>
<li> <b>Publications</b>:
<ul>
<li> <a rel="nofollow" class="external text" href="http://islab.ulsan.ac.kr/files/announcement/411/Adaptive%20Neighborhood%20Selection%20for%20Real-Time%20Surface%20Normal.pdf">Adaptive Neighborhood Selection for Real-Time Surface Normal Estimation from Organized Point Cloud Data Using Integral Images</a> (S. Holzer et al., 2012)
</li>
<li> <a rel="nofollow" class="external text" href="https://www.willowgarage.com/sites/default/files/holz_rgbd_seg.pdf">Real-Time Plane Segmentation using RGB-D Cameras</a> (Dirk Holz et al., 2012)
</li>
</ul>
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_integral_image_normal_estimation.html">pcl::IntegralImageNormalEstimation</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_estimate_normals_integral.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h1><span class="mw-headline" id="Decomposition">Decomposition</span></h1>
<p>When I talk about <i>decomposition</i>, I mean the process of creating an ordered, organized data structure from the points of the cloud, with some purpose in mind like making further analysis easier, or performing filters.
</p>
<h2><span class="mw-headline" id="k-d_tree"><i>k</i>-d tree</span></h2>
<p>A <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/K-d_tree"><i>k</i>-d tree</a> (<i>k</i>-dimensional tree) is a data structure that organizes a set of points in a <i>k</i>-dimensional space, in a way that makes range search operations very efficient (for example, finding the nearest neighbor of a point, which is the point that is closest to it in space; or finding all neighbors within a radius).
</p><p>It is a binary tree, that is, every non-leaf node in it has two children nodes, the "left" and "right" ones. Each level splits space on a specific dimension. For example, in 3-dimensional space, at the root node (first level) all children would be split based on the first dimension, X (points having coordinates with greater X values would go to the right subtree, points with lesser values to the left one). At the second level (the nodes we just created), the split would be done on the Y axis, following the same criteria. At the third level (the grandchildren), we would use the Z axis. At the fourth level, we would get back to the X axis, and so on. Usually, the median point is chosen to be root at every level.
</p><p><br>
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:702px;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:Kdtree.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/Kdtree.png" width="700" height="333" class="thumbimage"></a>  <div class="thumbcaption"><div class="magnify"><a href="http://robotica.unileon.es/mediawiki/index.php/File:Kdtree.png" class="internal" title="Enlarge"><img src="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/magnify-clip.png" width="15" height="11" alt=""></a></div>Example of a 2D <i>k</i>d-tree (image from Wikimedia Commons).</div></div></div></div>
<p><br>
In PCL, creating a <i>k</i>-d tree from a cloud is a straightforward and fast operation:
</p>
<h3><span class="mw-headline" id="Searching">Searching</span></h3>
<p>The following code snippet shows you how to use a <i>k</i>-d tree to perform efficient searches:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/search/kdtree.h&gt;</span>
&nbsp;
<span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;vector&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Object for storing the point cloud.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// kd-tree object.</span>
	pcl<span class="sy4">::</span><span class="me2">search</span><span class="sy4">::</span><span class="me2">KdTree</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> kdtree<span class="sy4">;</span>
	kdtree.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// We will find the 5 nearest neighbors of this point</span>
	<span class="co1">// (it does not have to be one of the cloud's, we can use any coordinate).</span>
	pcl<span class="sy4">::</span><span class="me2">PointXYZ</span> point<span class="sy4">;</span>
	point.<span class="me1">x</span> <span class="sy1">=</span> <span class="nu16">0.0524343</span><span class="sy4">;</span>
	point.<span class="me1">y</span> <span class="sy1">=</span> <span class="sy2">-</span><span class="nu16">0.58016</span><span class="sy4">;</span>
	point.<span class="me1">z</span> <span class="sy1">=</span> <span class="nu16">1.776</span><span class="sy4">;</span>
	<span class="co1">// This vector will store the output neighbors.</span>
	std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> pointIndices<span class="br0">(</span>5<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// This vector will store their squared distances to the search point.</span>
	std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span><span class="kw4">float</span><span class="sy1">&gt;</span> squaredDistances<span class="br0">(</span>5<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Perform the search, and print out results.</span>
	<span class="kw1">if</span> <span class="br0">(</span>kdtree.<span class="me1">nearestKSearch</span><span class="br0">(</span>point, 5, pointIndices, squaredDistances<span class="br0">)</span> <span class="sy1">&gt;</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"5 nearest neighbors of the point:"</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">size_t</span> i <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> i <span class="sy1">&lt;</span> pointIndices.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span>
			std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"<span class="es1">\t</span>"</span> <span class="sy1">&lt;&lt;</span> cloud<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span>pointIndices<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span>.<span class="me1">x</span>
					  <span class="sy1">&lt;&lt;</span> <span class="st0">" "</span> <span class="sy1">&lt;&lt;</span> cloud<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span>pointIndices<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span>.<span class="me1">y</span>
					  <span class="sy1">&lt;&lt;</span> <span class="st0">" "</span> <span class="sy1">&lt;&lt;</span> cloud<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span>pointIndices<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span>.<span class="me1">z</span>
					  <span class="sy1">&lt;&lt;</span> <span class="st0">" (squared distance: "</span> <span class="sy1">&lt;&lt;</span> squaredDistances<span class="br0">[</span>i<span class="br0">]</span> <span class="sy1">&lt;&lt;</span> <span class="st0">")"</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Now we find all neighbors within 3cm of the point</span>
	<span class="co1">// (inside a sphere of radius 3cm centered at the point).</span>
	<span class="kw1">if</span> <span class="br0">(</span>kdtree.<span class="me1">radiusSearch</span><span class="br0">(</span>point, 0.03, pointIndices, squaredDistances<span class="br0">)</span> <span class="sy1">&gt;</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"Neighbors within 3cm:"</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">size_t</span> i <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> i <span class="sy1">&lt;</span> pointIndices.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span>
			std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"<span class="es1">\t</span>"</span> <span class="sy1">&lt;&lt;</span> cloud<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span>pointIndices<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span>.<span class="me1">x</span>
					  <span class="sy1">&lt;&lt;</span> <span class="st0">" "</span> <span class="sy1">&lt;&lt;</span> cloud<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span>pointIndices<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span>.<span class="me1">y</span>
					  <span class="sy1">&lt;&lt;</span> <span class="st0">" "</span> <span class="sy1">&lt;&lt;</span> cloud<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span>pointIndices<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span>.<span class="me1">z</span>
					  <span class="sy1">&lt;&lt;</span> <span class="st0">" (squared distance: "</span> <span class="sy1">&lt;&lt;</span> squaredDistances<span class="br0">[</span>i<span class="br0">]</span> <span class="sy1">&lt;&lt;</span> <span class="st0">")"</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Another alternative would be <span style="color:#FF1493">"KdTreeFLANN"</span>, which makes use of <a rel="nofollow" class="external text" href="http://www.cs.ubc.ca/research/flann/">FLANN</a> (Fast Library for Approximate Nearest Neighbors).
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Radius | Neighbor count
</li>
<li> <b>Output</b>: Point indices, Squared distances
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/kdtree_search.php">How to use a KdTree to search</a>
</li>
<li> <b>API</b>:
<ul>
<li> <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1search_1_1_kd_tree.html">pcl::search::KdTree</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_kd_tree_f_l_a_n_n.html">pcl::KdTreeFLANN</a>
</li>
</ul>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_kdtree_search.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h2><span class="mw-headline" id="Octree">Octree</span></h2>
<p>Like the <i>k</i>-d tree, the <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Octree">octree</a> is an hierarchical tree data structure useful for searches, but also compression or downsampling. Each octree node (called a <i>voxel</i>, a term that will sound familiar for users of 3D engines, and which could be described as a "3D pixel", that is, a cube) has either eight children or no children. The root node describes a cubic bounding box which encapsulates all points. At every level, it becomes subdivided by a factor of 2 which results in an increased
voxel resolution. That way, we can selectively give more resolution to certain zones.
</p><p><br>
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:702px;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:Octree.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/Octree.png" width="700" height="402" class="thumbimage"></a>  <div class="thumbcaption"><div class="magnify"><a href="http://robotica.unileon.es/mediawiki/index.php/File:Octree.png" class="internal" title="Enlarge"><img src="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/magnify-clip.png" width="15" height="11" alt=""></a></div>Depiction of an octree (image from Wikimedia Commons).</div></div></div></div>
<p><br>
</p>
<h3><span class="mw-headline" id="Searching_2">Searching</span></h3>
<p>Downsampling will be covered in a different section, so now I will show you how to perform searches with an octree:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/octree/octree.h&gt;</span>
&nbsp;
<span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;vector&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Object for storing the point cloud.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Octree object, with a maximum resolution of 128</span>
	<span class="co1">// (resolution at lowest octree level).</span>
	pcl<span class="sy4">::</span><span class="me2">octree</span><span class="sy4">::</span><span class="me2">OctreePointCloudSearch</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> octree<span class="br0">(</span>128<span class="br0">)</span><span class="sy4">;</span>
	octree.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
	octree.<span class="me1">addPointsFromInputCloud</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// We will find all neighbors within the same voxel as this point.</span>
	<span class="co1">// (it does not have to be one of the cloud's, we can use any coordinate).</span>
	pcl<span class="sy4">::</span><span class="me2">PointXYZ</span> point<span class="sy4">;</span>
	point.<span class="me1">x</span> <span class="sy1">=</span> <span class="nu16">0.0524343</span><span class="sy4">;</span>
	point.<span class="me1">y</span> <span class="sy1">=</span> <span class="sy2">-</span><span class="nu16">0.58016</span><span class="sy4">;</span>
	point.<span class="me1">z</span> <span class="sy1">=</span> <span class="nu16">1.776</span><span class="sy4">;</span>
	<span class="co1">// This vector will store the output neighbors.</span>
	std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> pointIndices<span class="sy4">;</span>
	<span class="co1">// Perform the search, and print out results.</span>
	<span class="kw1">if</span> <span class="br0">(</span><span class="sy3">!</span> octree.<span class="me1">voxelSearch</span><span class="br0">(</span>point, pointIndices<span class="br0">)</span> <span class="sy1">&gt;</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"Neighbors in the same voxel:"</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">size_t</span> i <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> i <span class="sy1">&lt;</span> pointIndices.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span>
			std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"<span class="es1">\t</span>"</span> <span class="sy1">&lt;&lt;</span> cloud<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span>pointIndices<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span>.<span class="me1">x</span>
					  <span class="sy1">&lt;&lt;</span> <span class="st0">" "</span> <span class="sy1">&lt;&lt;</span> cloud<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span>pointIndices<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span>.<span class="me1">y</span>
					  <span class="sy1">&lt;&lt;</span> <span class="st0">" "</span> <span class="sy1">&lt;&lt;</span> cloud<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span>pointIndices<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span>.<span class="me1">z</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// We will find the 5 nearest neighbors of the point.</span>
	<span class="co1">// This vector will store their squared distances to the search point.</span>
	std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span><span class="kw4">float</span><span class="sy1">&gt;</span> squaredDistances<span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">(</span>octree.<span class="me1">nearestKSearch</span><span class="br0">(</span>point, 5, pointIndices, squaredDistances<span class="br0">)</span> <span class="sy1">&gt;</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"5 nearest neighbors of the point:"</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">size_t</span> i <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> i <span class="sy1">&lt;</span> pointIndices.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span>
			std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"<span class="es1">\t</span>"</span> <span class="sy1">&lt;&lt;</span> cloud<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span>pointIndices<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span>.<span class="me1">x</span>
					  <span class="sy1">&lt;&lt;</span> <span class="st0">" "</span> <span class="sy1">&lt;&lt;</span> cloud<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span>pointIndices<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span>.<span class="me1">y</span>
					  <span class="sy1">&lt;&lt;</span> <span class="st0">" "</span> <span class="sy1">&lt;&lt;</span> cloud<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span>pointIndices<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span>.<span class="me1">z</span>
					  <span class="sy1">&lt;&lt;</span> <span class="st0">" (squared distance: "</span> <span class="sy1">&lt;&lt;</span> squaredDistances<span class="br0">[</span>i<span class="br0">]</span> <span class="sy1">&lt;&lt;</span> <span class="st0">")"</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Now we find all neighbors within 3cm of the point</span>
	<span class="co1">// (inside a sphere of radius 3cm centered at the point).</span>
	<span class="co1">// The point DOES have to belong in the cloud.</span>
	<span class="kw1">if</span> <span class="br0">(</span>octree.<span class="me1">radiusSearch</span><span class="br0">(</span>point, 0.03, pointIndices, squaredDistances<span class="br0">)</span> <span class="sy1">&gt;</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"Neighbors within 3cm:"</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">size_t</span> i <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> i <span class="sy1">&lt;</span> pointIndices.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span>
			std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"<span class="es1">\t</span>"</span> <span class="sy1">&lt;&lt;</span> cloud<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span>pointIndices<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span>.<span class="me1">x</span>
					  <span class="sy1">&lt;&lt;</span> <span class="st0">" "</span> <span class="sy1">&lt;&lt;</span> cloud<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span>pointIndices<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span>.<span class="me1">y</span>
					  <span class="sy1">&lt;&lt;</span> <span class="st0">" "</span> <span class="sy1">&lt;&lt;</span> cloud<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span>pointIndices<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span>.<span class="me1">z</span>
					  <span class="sy1">&lt;&lt;</span> <span class="st0">" (squared distance: "</span> <span class="sy1">&lt;&lt;</span> squaredDistances<span class="br0">[</span>i<span class="br0">]</span> <span class="sy1">&lt;&lt;</span> <span class="st0">")"</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>As you can see, the code is mostly interchangeable with the one of the <i>k</i>d-tree.
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Radius | Neighbor count
</li>
<li> <b>Output</b>: Point indices, Squared distances
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/octree.php">Spatial Partitioning and Search Operations with Octrees</a>
</li>
<li> <b>API</b>:
<ul>
<li> <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1search_1_1_octree.html">pcl::search::Octree</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1octree_1_1_octree_point_cloud_search.html">pcl::octree::OctreePointCloudSearch</a>
</li>
</ul>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_octree_search.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h3><span class="mw-headline" id="Compressing.2FDecompressing">Compressing/Decompressing</span></h3>
<p>On the other hand, this is the code needed to compress and decompress a point cloud with PCL:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/compression/octree_pointcloud_compression.h&gt;</span>
<span class="co2">#include &lt;boost/thread/thread.hpp&gt;</span>
<span class="co2">#include &lt;pcl/visualization/pcl_visualizer.h&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Objects for storing the point clouds.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> decompressedCloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Octree compressor object.</span>
	<span class="co1">// Check /usr/include/pcl-&lt;version&gt;/pcl/compression/compression_profiles.h for more profiles.</span>
	<span class="co1">// The second parameter enables the output of information.</span>
	pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">OctreePointCloudCompression</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> octreeCompression<span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">MED_RES_ONLINE_COMPRESSION_WITHOUT_COLOR</span>, <span class="kw2">true</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Stringstream that will hold the compressed cloud.</span>
	std<span class="sy4">::</span><span class="me2">stringstream</span> compressedData<span class="sy4">;</span>
&nbsp;
	<span class="co1">// Compress the cloud (you would save the stream to disk).</span>
	octreeCompression.<span class="me1">encodePointCloud</span><span class="br0">(</span>cloud, compressedData<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Decompress the cloud.</span>
	octreeCompression.<span class="me1">decodePointCloud</span><span class="br0">(</span>compressedData, decompressedCloud<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Display the decompressed cloud.</span>
	boost<span class="sy4">::</span><span class="me2">shared_ptr</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">visualization</span><span class="sy4">::</span><span class="me2">PCLVisualizer</span><span class="sy1">&gt;</span> viewer<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">visualization</span><span class="sy4">::</span><span class="me2">PCLVisualizer</span><span class="br0">(</span><span class="st0">"Octree compression"</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
	viewer<span class="sy2">-</span><span class="sy1">&gt;</span>addPointCloud<span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>decompressedCloud, <span class="st0">"cloud"</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span>viewer<span class="sy2">-</span><span class="sy1">&gt;</span>wasStopped<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
	<span class="br0">{</span>
		viewer<span class="sy2">-</span><span class="sy1">&gt;</span>spinOnce<span class="br0">(</span>100<span class="br0">)</span><span class="sy4">;</span>
		boost<span class="sy4">::</span><span class="me2">this_thread</span><span class="sy4">::</span><span class="me2">sleep</span><span class="br0">(</span>boost<span class="sy4">::</span><span class="me2">posix_time</span><span class="sy4">::</span><span class="me2">microseconds</span><span class="br0">(</span>100000<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p><br>
</p>
<center><ul class="gallery mw-gallery-traditional">
		<li class="gallerybox" style="width: 335px"><div style="width: 335px">
			<div class="thumb" style="width: 330px;"><div style="margin:15px auto;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:BeforeCompression.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/BeforeCompression.png" width="207" height="120"></a></div></div>
			<div class="gallerytext">
<p>Original point cloud.
</p>
			</div>
		</div></li>
		<li class="gallerybox" style="width: 335px"><div style="width: 335px">
			<div class="thumb" style="width: 330px;"><div style="margin:15px auto;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:AfterCompression.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/AfterCompression.png" width="207" height="120"></a></div></div>
			<div class="gallerytext">
<p>Point cloud retrieved after octree compression.
</p>
			</div>
		</div></li>
</ul></center>
<p><br>
As you can see, the process has decreased the amount of points in the cloud. The default parameters of the <span style="color:#FF1493">"OctreePointCloudCompression"</span> object establish an octree resolution (at lowest level) of 1cm, and a coordinate precision of 1mm. These values can of course be changed to suit your needs, but simplifying the cloud in this way is an useful operation that we will cover later.
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Resolution, Compression profile
</li>
<li> <b>Output</b>: Compressed stream
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/compression.php">Point Cloud Compression</a>
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1io_1_1_octree_point_cloud_compression.html">pcl::io::OctreePointCloudCompression</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_octree_compress.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h3><span class="mw-headline" id="Detecting_changes">Detecting changes</span></h3>
<p>PCL has an octree-based object that allows to detect changes between two point clouds (for example, two clouds taken one after another with an OpenNI device). This object stores the trees of both clouds at the same time, and compares them, returning a list of indices of the points that are new in the second cloud (they did not exist in the first):
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/octree/octree.h&gt;</span>
&nbsp;
<span class="co2">#include &lt;iostream&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Objects for storing the point clouds.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloudA<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloudB<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read two PCD files from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloudA<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>2<span class="br0">]</span>, <span class="sy2">*</span>cloudB<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Change detector object, with a resolution of 128</span>
	<span class="co1">// (resolution at lowest octree level).</span>
	pcl<span class="sy4">::</span><span class="me2">octree</span><span class="sy4">::</span><span class="me2">OctreePointCloudChangeDetector</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> octree<span class="br0">(</span>128.0f<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Add cloudA to the octree.</span>
	octree.<span class="me1">setInputCloud</span><span class="br0">(</span>cloudA<span class="br0">)</span><span class="sy4">;</span>
	octree.<span class="me1">addPointsFromInputCloud</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// The change detector object is able to store two clouds at the same time;</span>
	<span class="co1">// with this we can reset the buffer but keep the previous tree saved.</span>
	octree.<span class="me1">switchBuffers</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Now, add cloudB to the octree like we did before.</span>
	octree.<span class="me1">setInputCloud</span><span class="br0">(</span>cloudB<span class="br0">)</span><span class="sy4">;</span>
	octree.<span class="me1">addPointsFromInputCloud</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> newPoints<span class="sy4">;</span>
	<span class="co1">// Get a vector with the indices of all points that are new in cloud B,</span>
	<span class="co1">// when compared with the ones that existed in cloud A.</span>
	octree.<span class="me1">getPointIndicesFromNewVoxels</span><span class="br0">(</span>newPoints<span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">size_t</span> i <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> i <span class="sy1">&lt;</span> newPoints.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span>
	<span class="br0">{</span>
		std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"Point ("</span> <span class="sy1">&lt;&lt;</span> cloudB<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span>newPoints<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span>.<span class="me1">x</span> <span class="sy1">&lt;&lt;</span> <span class="st0">", "</span>
				  <span class="sy1">&lt;&lt;</span> cloudB<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span>newPoints<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span>.<span class="me1">y</span> <span class="sy1">&lt;&lt;</span> <span class="st0">", "</span>
				  <span class="sy1">&lt;&lt;</span> cloudB<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span>newPoints<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span>.<span class="me1">z</span>
				  <span class="sy1">&lt;&lt;</span> <span class="st0">") was not in cloud A but is in cloud B"</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
	<span class="br0">}</span>
	std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> newPoints.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: First cloud, Second cloud, Resolution
</li>
<li> <b>Output</b>: Point indices
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/octree_change.php">Spatial change detection on unorganized point cloud data</a>
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1octree_1_1_octree_point_cloud_change_detector.html">pcl::octree::OctreePointCloudChangeDetector</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_change_detection.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h1><span class="mw-headline" id="Filtering">Filtering</span></h1>
<p>The raw point cloud, as returned from the sensor, usually needs some kind of polishing before being handed to processing algorithms. Normally, this is due to the low precision of the sensor, which leads to noise, incorrect measurements, holes in surfaces... Sometimes it is just the opposite: the cloud has so many points that processing it would take forever. Luckily, several filtering methods exist to "fix" many recurring errors in point clouds.
</p>
<h2><span class="mw-headline" id="Passthrough_filter">Passthrough filter</span></h2>
<p>A passthrough filter will remove any point from the cloud whose values do not fall in a certain range, user-given. For example, if you wanted to discard all points farther away than, say, 3 meters, you would run the filter on the Z coordinate with a range of [0,3]. This filter can be useful to discard unneeded objects from the cloud, but you may have to adapt a different reference frame if the default one (relative to the sensor) is not fitting. For example, filtering on the Y value to remove all points not sitting on a table will yield unwanted results if the camera was at an odd angle.
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/filters/passthrough.h&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Objects for storing the point clouds.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> filteredCloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Filter object.</span>
	pcl<span class="sy4">::</span><span class="me2">PassThrough</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> filter<span class="sy4">;</span>
	filter.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Filter out all points with Z values not in the [0-2] range.</span>
	filter.<span class="me1">setFilterFieldName</span><span class="br0">(</span><span class="st0">"z"</span><span class="br0">)</span><span class="sy4">;</span>
	filter.<span class="me1">setFilterLimits</span><span class="br0">(</span>0.0, 2.0<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	filter.<span class="me1">filter</span><span class="br0">(</span><span class="sy2">*</span>filteredCloud<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p><br>
</p>
<center><ul class="gallery mw-gallery-traditional">
		<li class="gallerybox" style="width: 335px"><div style="width: 335px">
			<div class="thumb" style="width: 330px;"><div style="margin:15px auto;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:BeforePassthrough.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/BeforePassthrough.png" width="207" height="120"></a></div></div>
			<div class="gallerytext">
<p>Original point cloud.
</p>
			</div>
		</div></li>
		<li class="gallerybox" style="width: 335px"><div style="width: 335px">
			<div class="thumb" style="width: 330px;"><div style="margin:15px auto;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:AfterPassthrough.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/AfterPassthrough.png" width="207" height="120"></a></div></div>
			<div class="gallerytext">
<p>Point cloud after applying a passthrough filter with Z in [0,2].
</p>
			</div>
		</div></li>
</ul></center>
<p><br>
The <span style="color:#FF1493">"setFilterLimitsNegative()"</span> function (not seen in the example) will tell the filter object whether to return the points inside the range ("false", the default value) or outside it ("true").
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Filter field, Filter limits, [Negative mode]
</li>
<li> <b>Output</b>: Filtered points
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/passthrough.php">Filtering a PointCloud using a PassThrough filter</a>
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_pass_through.html">pcl::PassThrough</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_passthrough_filter.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h2><span class="mw-headline" id="Conditional_removal">Conditional removal</span></h2>
<p>Another way of getting the exact same result than with the previous example would be to use a conditional removal filter. We can build any kind of condition we want for the values of the point:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/filters/conditional_removal.h&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Objects for storing the point clouds.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> filteredCloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// We must build a condition.</span>
	<span class="co1">// And "And" condition requires all tests to check true. "Or" conditions also available.</span>
	pcl<span class="sy4">::</span><span class="me2">ConditionAnd</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> condition<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">ConditionAnd</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// First test, the point's Z value must be greater than (GT) 0.</span>
	condition<span class="sy2">-</span><span class="sy1">&gt;</span>addComparison<span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">FieldComparison</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">ConstPtr</span><span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">FieldComparison</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span><span class="st0">"z"</span>, pcl<span class="sy4">::</span><span class="me2">ComparisonOps</span><span class="sy4">::</span><span class="me2">GT</span>, 0.0<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Second test, the point's Z value must be less than (LT) 2.</span>
	condition<span class="sy2">-</span><span class="sy1">&gt;</span>addComparison<span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">FieldComparison</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">ConstPtr</span><span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">FieldComparison</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span><span class="st0">"z"</span>, pcl<span class="sy4">::</span><span class="me2">ComparisonOps</span><span class="sy4">::</span><span class="me2">LT</span>, 2.0<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Checks available: GT, GE, LT, LE, EQ.</span>
&nbsp;
	<span class="co1">// Filter object.</span>
	pcl<span class="sy4">::</span><span class="me2">ConditionalRemoval</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> filter<span class="sy4">;</span>
	filter.<span class="me1">setCondition</span><span class="br0">(</span>condition<span class="br0">)</span><span class="sy4">;</span>
	filter.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// If true, points that do not pass the filter will be set to a certain value (default NaN).</span>
	<span class="co1">// If false, they will be just removed, but that could break the structure of the cloud</span>
	<span class="co1">// (organized clouds are clouds taken from camera-like sensors that return a matrix-like image).</span>
	filter.<span class="me1">setKeepOrganized</span><span class="br0">(</span><span class="kw2">true</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// If keep organized was set true, points that failed the test will have their Z value set to this.</span>
	filter.<span class="me1">setUserFilterValue</span><span class="br0">(</span>0.0<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	filter.<span class="me1">filter</span><span class="br0">(</span><span class="sy2">*</span>filteredCloud<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Condition, [Keep organized]
</li>
<li> <b>Output</b>: Filtered points
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/remove_outliers.php">Removing outliers using a Conditional or RadiusOutlier removal</a>
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_conditional_removal.html">pcl::ConditionalRemoval</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_conditional_removal.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h2><span class="mw-headline" id="Outlier_removal">Outlier removal</span></h2>
<p>Outliers are lonely points that are spread here and there in the cloud, like annoying mosquitoes. They are the product of the sensor's inaccuracy, which registers measurements where there should not be any. Outliers are considered undesired noise because they can introduce errors in calculations, like for example the normal estimation. Hence, trimming they out of the cloud will not only make computations faster (because the less points there are, the less time it takes, as we will see with downsampling) but also help us get more precise values.
</p>
<h3><span class="mw-headline" id="Radius-based">Radius-based</span></h3>
<p>The radius-based outlier removal is the simplest method of all. You must specify a search radius and the minimum number of neighbors than a point must have to avoid being labelled as outlier. The algorithm will then iterate through all points (which can be slow in if the cloud is big) and perform the check: if less than that number of points are found within the radius, it is removed.
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/filters/radius_outlier_removal.h&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Objects for storing the point clouds.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> filteredCloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Filter object.</span>
	pcl<span class="sy4">::</span><span class="me2">RadiusOutlierRemoval</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> filter<span class="sy4">;</span>
	filter.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Every point must have 10 neighbors within 15cm, or it will be removed.</span>
	filter.<span class="me1">setRadiusSearch</span><span class="br0">(</span>0.15<span class="br0">)</span><span class="sy4">;</span>
	filter.<span class="me1">setMinNeighborsInRadius</span><span class="br0">(</span>10<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	filter.<span class="me1">filter</span><span class="br0">(</span><span class="sy2">*</span>filteredCloud<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>All PCL classes that inherit from <span style="color:#FF1493">"pcl::FilterIndices"</span> (like <span style="color:#FF1493">"pcl::RadiusOutlierRemoval"</span>) provide the function <span style="color:#FF1493">"setNegative()"</span>, which if set to true, makes the filter return the points that did NOT pass the filter.
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Radius, Neighbor count
</li>
<li> <b>Output</b>: Filtered points
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/remove_outliers.php">Removing outliers using a Conditional or RadiusOutlier removal</a>
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_radius_outlier_removal.html">pcl::RadiusOutlierRemoval</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_radius_outlier_removal.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h3><span class="mw-headline" id="Statistical">Statistical</span></h3>
<p>The statistical outlier removal process is a bit more refined. First, for every point, the mean distance to its <i>K</i> neighbors is computed. Then, if we asume that the result is a <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Normal_distribution">normal (gaussian) distribution</a> with a mean <i>μ</i> and a standard deviation <i>σ</i>, we can deem it safe to remove all points with mean distances that fall out of the global mean plus deviation. Basically, it runs a statistical analysis of the distances between neighboring points, and trims all which are not considered "normal" (you define what "normal" is with the parameters of the algorithm).
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/filters/statistical_outlier_removal.h&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Objects for storing the point clouds.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> filteredCloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Filter object.</span>
	pcl<span class="sy4">::</span><span class="me2">StatisticalOutlierRemoval</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> filter<span class="sy4">;</span>
	filter.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Set number of neighbors to consider to 50.</span>
	filter.<span class="me1">setMeanK</span><span class="br0">(</span>50<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Set standard deviation multiplier to 1.</span>
	<span class="co1">// Points with a distance larger than 1 standard deviation of the mean distance will be outliers.</span>
	filter.<span class="me1">setStddevMulThresh</span><span class="br0">(</span>1.0<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	filter.<span class="me1">filter</span><span class="br0">(</span><span class="sy2">*</span>filteredCloud<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>You can make use of <span style="color:#FF1493">"setNegative()"</span> with this filter too.
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Neighbor count, Deviation multiplier
</li>
<li> <b>Output</b>: Filtered points
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/statistical_outlier.php">Removing outliers using a StatisticalOutlierRemoval filter</a>
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_statistical_outlier_removal.html">pcl::StatisticalOutlierRemoval</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_statistical_outlier_removal.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h2><span class="mw-headline" id="Resampling">Resampling</span></h2>
<p>Resampling means changing the number of points of the cloud, either by reducing (downsampling) or increasing (upsampling). Both have a purpose, as we will see.
</p>
<h3><span class="mw-headline" id="Downsampling">Downsampling</span></h3>
<p>A sensor like Kinect or Xtion produces a cloud with 307200 (640x480) points. Believe it or not, that is a lot of information, and the new Kinect is already out there, working at a higher resolution. Keep in mind that, if we were to perform a simple operation on every point of a cloud, it would be of <i>O(n)</i>, n being the number of points. If we had to compare every point with its <i>k</i> nearest neighbors, it would be <i>O(nk)</i>. You may have noticed by now that some of the algorithms I showed you take several seconds to run on your PC; you now know why.
</p><p>Optimization techniques are being implemented as I write this to allow PCL to employ the computer's GPU (graphic card) to perform the computations using <a rel="nofollow" class="external text" href="https://developer.nvidia.com/about-cuda">CUDA</a>. Many classes already provide an alternative in the <span style="color:#FF1493">"pcl::gpu"</span> namespace. This offers dramatic improvements in speed, but it is not always a possibility.
</p><p>Another option is to reduce the complexity of the cloud, that is, to remove all points that are not needed for the purpose. There are several ways to do this. You could trim all outliers from the cloud, then perform segmentation to extract only the parts that interest you. A common operation is also downsampling, which will give you back a cloud that, for all intents and purposes, equivalent to the original one, despite having less points.
</p><p>Downsampling is done via <i>voxelization</i>. I already explained what voxels were in the <a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Octree"> octree section</a>. The cloud is divided in multiple cube-shaped regions with the desired resolution. Then, all points inside every voxel are processed so only one remains. The simplest way would be to randomly select one of them, but a more accurate approach would be to compute the <a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Computing_the_centroid" title="PCL/OpenNI tutorial 2: Cloud processing (basic)">centroid</a>, which is the point whose coordinates are the mean values of all the points that belong to the voxel.
</p><p>If done with sensible parameters, downsampling will yield results that are precise enough to work with, at the cost of less CPU power.
</p>
<h4><span class="mw-headline" id="Voxel_grid">Voxel grid</span></h4>
<p>A straightforward way of downsampling a cloud:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/filters/voxel_grid.h&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Objects for storing the point clouds.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> filteredCloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Filter object.</span>
	pcl<span class="sy4">::</span><span class="me2">VoxelGrid</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> filter<span class="sy4">;</span>
	filter.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// We set the size of every voxel to be 1x1x1cm</span>
	<span class="co1">// (only one point per every cubic centimeter will survive).</span>
	filter.<span class="me1">setLeafSize</span><span class="br0">(</span>0.01f, 0.01f, 0.01f<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	filter.<span class="me1">filter</span><span class="br0">(</span><span class="sy2">*</span>filteredCloud<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p><br>
</p>
<center><ul class="gallery mw-gallery-traditional">
		<li class="gallerybox" style="width: 335px"><div style="width: 335px">
			<div class="thumb" style="width: 330px;"><div style="margin:15px auto;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:BeforeDownsampling.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/BeforeDownsampling.png" width="207" height="120"></a></div></div>
			<div class="gallerytext">
<p>Original point cloud.
</p>
			</div>
		</div></li>
		<li class="gallerybox" style="width: 335px"><div style="width: 335px">
			<div class="thumb" style="width: 330px;"><div style="margin:15px auto;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:AfterDownsampling.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/AfterDownsampling.png" width="207" height="120"></a></div></div>
			<div class="gallerytext">
<p>Point cloud after being downsampled with a leaf size of 1cm.
</p>
			</div>
		</div></li>
</ul></center>
<p><br>
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Voxel size
</li>
<li> <b>Output</b>: Downsampled cloud
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/voxel_grid.php">Downsampling a PointCloud using a VoxelGrid filter</a>
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_voxel_grid.html">pcl::VoxelGrid</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_downsample.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h4><span class="mw-headline" id="Uniform_sampling">Uniform sampling</span></h4>
<p>This class does basically the same, but it outputs the indices of the points that survived the process. It is a common way of choosing keypoints when computing <a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_4:_3D_object_recognition_(descriptors)" title="PCL/OpenNI tutorial 4: 3D object recognition (descriptors)">descriptors</a>.
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/keypoints/uniform_sampling.h&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Objects for storing the point clouds.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> filteredCloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Uniform sampling object.</span>
	pcl<span class="sy4">::</span><span class="me2">UniformSampling</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> filter<span class="sy4">;</span>
	filter.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// We set the size of every voxel to be 1x1x1cm</span>
	<span class="co1">// (only one point per every cubic centimeter will survive).</span>
	filter.<span class="me1">setRadiusSearch</span><span class="br0">(</span>0.01f<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// We need an additional object to store the indices of surviving points.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> keypointIndices<span class="sy4">;</span>
&nbsp;
	filter.<span class="me1">compute</span><span class="br0">(</span>keypointIndices<span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">copyPointCloud</span><span class="br0">(</span><span class="sy2">*</span>cloud, keypointIndices.<span class="me1">points</span>, <span class="sy2">*</span>filteredCloud<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Voxel size
</li>
<li> <b>Output</b>: Point indices
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_uniform_sampling.html">pcl::UniformSampling</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_downsample_uniform.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h3><span class="mw-headline" id="Upsampling">Upsampling</span></h3>
<p>Upsampling is a form of <a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#Reconstruction" title="PCL/OpenNI tutorial 2: Cloud processing (basic)"> surface reconstruction</a>, but I put it here. When you have fewer points than you would like, upsampling can help you to recover the original surface(s), by <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Upsampling">interpolating</a> the ones you currently have, which is just a sophisticated guess. The result will never be a hundred percent accurate, but sometimes it is the only choice. So, before downsampling your clouds, be sure to keep a copy of the original data!
</p><p>PCL uses the <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Moving_least_squares">Moving Least Squares (MLS)</a> algorithm for this. The code looks like:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/surface/mls.h&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Objects for storing the point clouds.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> filteredCloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Filtering object.</span>
	pcl<span class="sy4">::</span><span class="me2">MovingLeastSquares</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span>, pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> filter<span class="sy4">;</span>
	filter.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Object for searching.</span>
	pcl<span class="sy4">::</span><span class="me2">search</span><span class="sy4">::</span><span class="me2">KdTree</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> kdtree<span class="sy4">;</span>
	filter.<span class="me1">setSearchMethod</span><span class="br0">(</span>kdtree<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Use all neighbors in a radius of 3cm.</span>
	filter.<span class="me1">setSearchRadius</span><span class="br0">(</span>0.03<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Upsampling method. Other possibilites are DISTINCT_CLOUD, RANDOM_UNIFORM_DENSITY</span>
	<span class="co1">// and VOXEL_GRID_DILATION. NONE disables upsampling. Check the API for details.</span>
	filter.<span class="me1">setUpsamplingMethod</span><span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">MovingLeastSquares</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span>, pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">SAMPLE_LOCAL_PLANE</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Radius around each point, where the local plane will be sampled.</span>
	filter.<span class="me1">setUpsamplingRadius</span><span class="br0">(</span>0.03<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Sampling step size. Bigger values will yield less (if any) new points.</span>
	filter.<span class="me1">setUpsamplingStepSize</span><span class="br0">(</span>0.02<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	filter.<span class="me1">process</span><span class="br0">(</span><span class="sy2">*</span>filteredCloud<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p><br>
</p>
<center><ul class="gallery mw-gallery-traditional">
		<li class="gallerybox" style="width: 335px"><div style="width: 335px">
			<div class="thumb" style="width: 330px;"><div style="margin:15px auto;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:PCL_upsampling_original.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/PCL_upsampling_original.png" width="224" height="120"></a></div></div>
			<div class="gallerytext">
<p>Original point cloud (coffee mug on a table).
</p>
			</div>
		</div></li>
		<li class="gallerybox" style="width: 335px"><div style="width: 335px">
			<div class="thumb" style="width: 330px;"><div style="margin:15px auto;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:PCL_upsampling_downsampled.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/PCL_upsampling_downsampled.png" width="224" height="120"></a></div></div>
			<div class="gallerytext">
<p>Downsampled with a leaf size of 1cm.
</p>
			</div>
		</div></li>
		<li class="gallerybox" style="width: 335px"><div style="width: 335px">
			<div class="thumb" style="width: 330px;"><div style="margin:15px auto;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:PCL_upsampling_local_plane.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/PCL_upsampling_local_plane.png" width="224" height="120"></a></div></div>
			<div class="gallerytext">
<p>Upsampled using SAMPLE_LOCAL_PLANE (upsampling radius 3cm, step size 2cm).
</p>
			</div>
		</div></li>
		<li class="gallerybox" style="width: 335px"><div style="width: 335px">
			<div class="thumb" style="width: 330px;"><div style="margin:15px auto;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:PCL_upsampling_uniform_density.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/PCL_upsampling_uniform_density.png" width="224" height="120"></a></div></div>
			<div class="gallerytext">
<p>Upsampled using RANDOM_UNIFORM_DENSITY (target point density of 300 per 3cm radius).
</p>
			</div>
		</div></li>
</ul></center>
<p><br>
Check the <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_moving_least_squares.html#ac29ad97b98353d64ce64e2ff924f7d20">setUpsamplingMethod()</a> API to see all upsampling methods available, and the parameters you need to set for them to work.
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Search radius, Upsampling method, [Upsampling parameters]
</li>
<li> <b>Output</b>: Upsampled cloud
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_upsample.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h1><span class="mw-headline" id="Reconstruction">Reconstruction</span></h1>
<h2><span class="mw-headline" id="Surface_smoothing">Surface smoothing</span></h2>
<p>As stated, depth sensors are not very accurate, and the resulting clouds have measurement errors, outliers, holes in surfaces, etc. Surfaces can be reconstructed by means of an algorithm, that iterates through all points and interpolates the data, trying to guess how the original surface was. Like with upsampling, PCL uses the <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Moving_least_squares">MLS</a> algorithm and class. Performing this step is important, because the resulting cloud's normals will be more accurate.
</p><p>Surface smoothing is easily done with the following code:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/surface/mls.h&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Object for storing the point cloud.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// The output will also contain the normals.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointNormal</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> smoothedCloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointNormal</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Smoothing object (we choose what point types we want as input and output).</span>
	pcl<span class="sy4">::</span><span class="me2">MovingLeastSquares</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span>, pcl<span class="sy4">::</span><span class="me2">PointNormal</span><span class="sy1">&gt;</span> filter<span class="sy4">;</span>
	filter.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Use all neighbors in a radius of 3cm.</span>
	filter.<span class="me1">setSearchRadius</span><span class="br0">(</span>0.03<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// If true, the surface and normal are approximated using a polynomial estimation</span>
	<span class="co1">// (if false, only a tangent one).</span>
	filter.<span class="me1">setPolynomialFit</span><span class="br0">(</span><span class="kw2">true</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// We can tell the algorithm to also compute smoothed normals (optional).</span>
	filter.<span class="me1">setComputeNormals</span><span class="br0">(</span><span class="kw2">true</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// kd-tree object for performing searches.</span>
	pcl<span class="sy4">::</span><span class="me2">search</span><span class="sy4">::</span><span class="me2">KdTree</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> kdtree<span class="sy4">;</span>
	filter.<span class="me1">setSearchMethod</span><span class="br0">(</span>kdtree<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	filter.<span class="me1">process</span><span class="br0">(</span><span class="sy2">*</span>smoothedCloud<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>The output cloud will also contain the improved normals of the smoother cloud.
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Search radius, [Polynomial fit], [Compute normals]
</li>
<li> <b>Output</b>: Smoothed cloud, [Smoothed normals]
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/resampling.php">Smoothing and normal estimation based on polynomial reconstruction</a>
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_surface_smoothing.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<hr>
<hr>
<p>Go to root: <a href="http://robotica.unileon.es/mediawiki/index.php/PhD-3D-Object-Tracking" title="PhD-3D-Object-Tracking">PhD-3D-Object-Tracking</a>
</p><p>Links to articles:
</p><p><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_0:_The_very_basics" title="PCL/OpenNI tutorial 0: The very basics">PCL/OpenNI tutorial 0: The very basics</a>
</p><p><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_1:_Installing_and_testing" title="PCL/OpenNI tutorial 1: Installing and testing">PCL/OpenNI tutorial 1: Installing and testing</a>
</p><p><strong class="selflink">PCL/OpenNI tutorial 2: Cloud processing (basic)</strong>
</p><p><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)" title="PCL/OpenNI tutorial 3: Cloud processing (advanced)">PCL/OpenNI tutorial 3: Cloud processing (advanced)</a>
</p><p><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_4:_3D_object_recognition_(descriptors)" title="PCL/OpenNI tutorial 4: 3D object recognition (descriptors)">PCL/OpenNI tutorial 4: 3D object recognition (descriptors)</a>
</p><p><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_5:_3D_object_recognition_(pipeline)" title="PCL/OpenNI tutorial 5: 3D object recognition (pipeline)">PCL/OpenNI tutorial 5: 3D object recognition (pipeline)</a>
</p><p><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_troubleshooting" title="PCL/OpenNI troubleshooting">PCL/OpenNI troubleshooting</a>
</p>
<!-- 
NewPP limit report
CPU time usage: 0.676 seconds
Real time usage: 0.728 seconds
Preprocessor visited node count: 488/1000000
Preprocessor generated node count: 940/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:245-0!*!0!!en!2!* and timestamp 20150622113255
 -->
</div>								<div class="printfooter">
				Retrieved from "<a href="http://robotica.unileon.es/mediawiki/index.php?title=PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)&oldid=4666">http://robotica.unileon.es/mediawiki/index.php?title=PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)&amp;oldid=4666</a>"				</div>
												<div id="catlinks" class="catlinks catlinks-allhidden"></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
				<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
	<h3 id="p-personal-label">Personal tools</h3>
	<ul>
<li id="pt-login"><a href="http://robotica.unileon.es/mediawiki/index.php?title=Special:UserLogin&returnto=PCL%2FOpenNI+tutorial+2%3A+Cloud+processing+%28basic%29" title="You are encouraged to log in; however, it is not mandatory [alt-shift-o]" accesskey="o">Log in</a></li>	</ul>
</div>
				<div id="left-navigation">
					<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
	<h3 id="p-namespaces-label">Namespaces</h3>
	<ul>
					<li id="ca-nstab-main" class="selected"><span><a href="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE.html" title="View the content page [alt-shift-c]" accesskey="c">Page</a></span></li>
					<li id="ca-talk" class="new"><span><a href="http://robotica.unileon.es/mediawiki/index.php?title=Talk:PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)&action=edit&redlink=1" title="Discussion about the content page [alt-shift-t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>
<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
	<h3 id="mw-vector-current-variant">
		</h3>
	<h3 id="p-variants-label" tabindex="0"><span>Variants</span><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#" tabindex="-1"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
				</div>
				<div id="right-navigation">
					<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
	<h3 id="p-views-label">Views</h3>
	<ul>
					<li id="ca-view" class="selected"><span><a href="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE.html">Read</a></span></li>
					<li id="ca-viewsource"><span><a href="http://robotica.unileon.es/mediawiki/index.php?title=PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)&action=edit" title="This page is protected.
You can view its source [alt-shift-e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="http://robotica.unileon.es/mediawiki/index.php?title=PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)&action=history" title="Past revisions of this page [alt-shift-h]" accesskey="h">View history</a></span></li>
			</ul>
</div>
<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
	<h3 id="p-cactions-label" tabindex="0"><span>Actions</span><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#" tabindex="-1"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
<div id="p-search" role="search">
	<h3><label for="searchInput">Search</label></h3>
	<form action="http://robotica.unileon.es/mediawiki/index.php" id="searchform">
				<div id="simpleSearch">
						<input name="search" placeholder="Search" title="Search Robótica - ULE [alt-shift-f]" accesskey="f" id="searchInput" tabindex="1" autocomplete="off">						<button type="submit" name="button" title="Search the pages for this text" id="searchButton"><img src="./PCL_OpenNI tutorial 2_ Cloud processing (basic) - Robótica - ULE_files/search-ltr.png" alt="Search" width="12" height="13"></button>								<input type="hidden" name="title" value="Special:Search">
		</div>
	</form>
</div>
				</div>
			</div>
			<div id="mw-panel" class="collapsible-nav">
					<div id="p-logo" role="banner"><a style="background-image: url(/mediawiki/skins/common/images/LogoRobotica_small.png);" href="http://robotica.unileon.es/mediawiki/index.php/Home" title="Visit the main page"></a></div>
				<div class="portal first persistent" role="navigation" id="p-Contents" aria-labelledby="p-Contents-label">
	<h3 id="p-Contents-label">Contents</h3>
	<div class="body">
		<ul>
			<li id="n-Home"><a href="http://robotica.unileon.es/mediawiki/index.php/Home">Home</a></li>
			<li id="n-People"><a href="http://robotica.unileon.es/mediawiki/index.php/People">People</a></li>
			<li id="n-Publications"><a href="http://robotica.unileon.es/mediawiki/index.php/Publications">Publications</a></li>
			<li id="n-Activities"><a href="http://robotica.unileon.es/mediawiki/index.php/Activities">Activities</a></li>
			<li id="n-Projects"><a href="http://robotica.unileon.es/mediawiki/index.php/Projects">Projects</a></li>
			<li id="n-Software"><a href="http://robotica.unileon.es/mediawiki/index.php/Software">Software</a></li>
		</ul>
	</div>
</div>
<div class="portal expanded" role="navigation" id="p-Wiki" aria-labelledby="p-Wiki-label">
	<h3 id="p-Wiki-label" tabindex="2"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#">Wiki</a></h3>
	<div class="body" style="display: block;">
		<ul>
			<li id="n-recentchanges"><a href="http://robotica.unileon.es/mediawiki/index.php/Special:RecentChanges" title="A list of recent changes in the wiki [alt-shift-r]" accesskey="r">Recent changes</a></li>
			<li id="n-randompage"><a href="http://robotica.unileon.es/mediawiki/index.php/Special:Random" title="Load a random page [alt-shift-x]" accesskey="x">Random page</a></li>
			<li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" rel="nofollow" title="The place to find out">Help</a></li>
		</ul>
	</div>
</div>
<div class="portal collapsed" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
	<h3 id="p-tb-label" tabindex="3"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)#">Tools</a></h3>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="http://robotica.unileon.es/mediawiki/index.php/Special:WhatLinksHere/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)" title="A list of all wiki pages that link here [alt-shift-j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="http://robotica.unileon.es/mediawiki/index.php/Special:RecentChangesLinked/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)" title="Recent changes in pages linked from this page [alt-shift-k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="http://robotica.unileon.es/mediawiki/index.php/Special:SpecialPages" title="A list of all special pages [alt-shift-q]" accesskey="q">Special pages</a></li>
			<li id="t-print"><a href="http://robotica.unileon.es/mediawiki/index.php?title=PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)&printable=yes" rel="alternate" title="Printable version of this page [alt-shift-p]" accesskey="p">Printable version</a></li>
			<li id="t-permalink"><a href="http://robotica.unileon.es/mediawiki/index.php?title=PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)&oldid=4666" title="Permanent link to this revision of the page">Permanent link</a></li>
			<li id="t-info"><a href="http://robotica.unileon.es/mediawiki/index.php?title=PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)&action=info">Page information</a></li>
		</ul>
	</div>
</div>
			</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 23 February 2015, at 11:22.</li>
											<li id="footer-info-viewcount">This page has been accessed 20,989 times.</li>
									</ul>
									<div style="clear:both"></div>
		</div>
		<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","skins.vector.collapsibleNav"],null,true);
}</script>
<script>if(window.mw){
mw.loader.state({"site":"ready"});
}</script>
<!-- Served in 0.079 secs. -->
	

<div class="suggestions" style="display: none; font-size: 13px;"><div class="suggestions-results"></div><div class="suggestions-special"></div></div></body></html>