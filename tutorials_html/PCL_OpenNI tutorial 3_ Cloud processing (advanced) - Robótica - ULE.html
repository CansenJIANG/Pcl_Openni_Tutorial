<!DOCTYPE html>
<!-- saved from url=(0097)http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced) -->
<html lang="en" dir="ltr" class="client-js"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="UTF-8"><title>PCL/OpenNI tutorial 3: Cloud processing (advanced) - Robótica - ULE</title>
<meta name="generator" content="MediaWiki 1.22.5">
<link rel="shortcut icon" href="http://robotica.unileon.es/mediawiki/skins/common/images/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="http://robotica.unileon.es/mediawiki/opensearch_desc.php" title="Robótica - ULE (en)">
<link rel="EditURI" type="application/rsd+xml" href="http://robotica.unileon.es/mediawiki/api.php?action=rsd">
<link rel="alternate" type="application/atom+xml" title="Robótica - ULE Atom feed" href="http://robotica.unileon.es/mediawiki/index.php?title=Special:RecentChanges&feed=atom">
<link rel="stylesheet" href="http://robotica.unileon.es/mediawiki/load.php?debug=false&lang=en&modules=ext.geshi.local%7Cmediawiki.legacy.commonPrint%2Cshared%7Cskins.vector&only=styles&skin=vector&*">
<style>
.mw-collapsible-toggle{float:right} li .mw-collapsible-toggle{float:none} .mw-collapsible-toggle-li{list-style:none}
/* cache key: wikidb:resourceloader:filter:minify-css:7:4250852ed2349a0d4d0fc6509a3e7d4c */
.suggestions{overflow:hidden;position:absolute;top:0;left:0;width:0;border:none;z-index:1099;padding:0;margin:-1px -1px 0 0} html > body .suggestions{margin:-1px 0 0 0}.suggestions-special{position:relative;background-color:white;cursor:pointer;border:solid 1px #aaaaaa;padding:0;margin:0;margin-top:-2px;display:none;padding:0.25em 0.25em;line-height:1.25em}.suggestions-results{background-color:white;cursor:pointer;border:solid 1px #aaaaaa;padding:0;margin:0}.suggestions-result{color:black;margin:0;line-height:1.5em;padding:0.01em 0.25em;text-align:left}.suggestions-result-current{background-color:#4C59A6;color:white}.suggestions-special .special-label{color:gray;text-align:left}.suggestions-special .special-query{color:black;font-style:italic;text-align:left}.suggestions-special .special-hover{background-color:silver}.suggestions-result-current .special-label,.suggestions-result-current .special-query{color:white}.autoellipsis-matched,.highlight{font-weight:bold}
/* cache key: wikidb:resourceloader:filter:minify-css:7:9780324491b653a3780e2d029bdc140c */
.postedit-container{margin:0 auto;position:fixed;top:0;height:0;left:50%;z-index:1000;font-size:13px}.postedit-container:hover{cursor:pointer}.postedit{position:relative;top:0.6em;left:-50%;padding:.6em 3.6em .6em 1.1em;line-height:1.5625em;color:#626465;background-color:#f4f4f4;border:1px solid #dcd9d9;text-shadow:0 0.0625em 0 rgba(255,255,255,0.5);border-radius:5px;-webkit-box-shadow:0 2px 5px 0 #ccc;box-shadow:0 2px 5px 0 #ccc;-webkit-transition:all 0.25s ease-in-out;-moz-transition:all 0.25s ease-in-out;-ms-transition:all 0.25s ease-in-out;-o-transition:all 0.25s ease-in-out;transition:all 0.25s ease-in-out}.skin-monobook .postedit{top:6em !important}.postedit-faded{opacity:0}.postedit-icon{padding-left:41px;  line-height:25px;background-repeat:no-repeat;background-position:8px 50%}.postedit-icon-checkmark{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABblBMVEUAAAD///////9PfTf///80aRdTgjn///9Feij///////////9Rfzf///////////9PfjZRgDh1o1xOfTb///////+bwYqLtnj///////9PfTa82K////9WhT6YxIL///9QgDdTgzr////////j7uDl7eLq8efi693k7OH///////9UhjuBr2rp9uRUhjr///9YljVKgir///9WiTlYjT3////9/v57vFlbkT5PjC9dlD/5/fhuq09stUTs9uhxuElctCpfnT1huDFloEZloUZmpENmvDZpvDxpvTxqvjxrvT5rvT9rwTxsqktswD5uwkBvuUdxw0NztFBztU9ztVBzwkp0tlJ1xkd2t1R3uVR4w1F4xk54x014yE15uVZ5v1R5xVB6v1R7yFJ8wVh9xVl9yFR9yVd9ylN+xVh+yFd/x1l/yFeAylmEx1+Ny2uY0Hqe04Wj1Ymv3Ze33qLD47TJ5L3O6cPU7Mrq9eb2+/Q4j37OAAAAQHRSTlMAAQIEBAUFBQwPFB4fJCUoKiosQEhJS01RUlZZXmdydXaChYuSlJSWmJmoq6uur8LExcvM19fg5ejt8fX2+Pr7SljgewAAAKpJREFUGBkFwQNCAwAAAMDLtl3LtrG4rWXbtvX77gAgZ6grFwC0bhwNVgKgdPZx8b0dgLi+s7Wn0VoAqpfOI9+BNADZI7fLrz2pSEwGHZuH+78lSK8ZLkLezF3ooyUG3VPXq2USei9WngeyoG195yBYWDF3E/2pAhl1e9Gr8bGT+bfOFCC2fnvh4X7rcqIAQNNu+HT6sxkAjceTL/2ZAIhv+PorBwBJxfkA//dFHSCBy/UTAAAAAElFTkSuQmCC);background-image:url(http://robotica.unileon.es/mediawiki/resources/mediawiki.action/images/green-checkmark.png?2014-04-10T08:01:40Z)!ie;background-position:left}.postedit-close{position:absolute;padding:0 .8em;right:0;top:0;font-size:1.25em;font-weight:bold;line-height:2.3em;color:black;text-shadow:0 0.0625em 0 white;text-decoration:none;opacity:0.2;filter:alpha(opacity=20)}.postedit-close:hover{color:black;text-decoration:none;opacity:0.4;filter:alpha(opacity=40)}
/* cache key: wikidb:resourceloader:filter:minify-css:7:9b39df22efb31003b8c266f2194113b0 */</style><style>
.suggestions a.mw-searchSuggest-link,.suggestions a.mw-searchSuggest-link:hover,.suggestions a.mw-searchSuggest-link:active,.suggestions a.mw-searchSuggest-link:focus{text-decoration:none;color:black}.suggestions-result-current a.mw-searchSuggest-link,.suggestions-result-current a.mw-searchSuggest-link:hover,.suggestions-result-current a.mw-searchSuggest-link:active,.suggestions-result-current a.mw-searchSuggest-link:focus{color:white}
/* cache key: wikidb:resourceloader:filter:minify-css:7:52b1797f70c7e4094dfa4191101944e8 */</style><meta name="ResourceLoaderDynamicStyles" content="">
<style>a:lang(ar),a:lang(ckb),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: wikidb:resourceloader:filter:minify-css:7:c2f15db357ed1b34653e004540bd5f70 */</style>

<script src="./PCL_OpenNI tutorial 3_ Cloud processing (advanced) - Robótica - ULE_files/load.php"></script><script src="./PCL_OpenNI tutorial 3_ Cloud processing (advanced) - Robótica - ULE_files/load(1).php"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)","wgTitle":"PCL/OpenNI tutorial 3: Cloud processing (advanced)","wgCurRevisionId":4684,"wgRevisionId":4684,"wgArticleId":292,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)","wgIsProbablyEditable":false,"wgRestrictionEdit":["sysop"],"wgRestrictionMove":["sysop"]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"vector-simplesearch":1,"watchcreations":0,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,
"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"useeditwarning":1,"prefershttps":1,"language":"en","variant-gan":"gan","variant-iu":"iu","variant-kk":"kk","variant-ku":"ku","variant-shi":"shi","variant-sr":"sr","variant-tg":"tg","variant-uz":"uz","variant-zh":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"variant":"en"});},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});},{},{});
/* cache key: wikidb:resourceloader:filter:minify-js:7:5a69c7e0fa6557851b6dea8a62efaffb */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script><script src="./PCL_OpenNI tutorial 3_ Cloud processing (advanced) - Robótica - ULE_files/load(2).php"></script>
<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000ff;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #666666;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #000099; font-weight: bold;}
.cpp.source-cpp .es1 {color: #000099; font-weight: bold;}
.cpp.source-cpp .es2 {color: #660099; font-weight: bold;}
.cpp.source-cpp .es3 {color: #660099; font-weight: bold;}
.cpp.source-cpp .es4 {color: #660099; font-weight: bold;}
.cpp.source-cpp .es5 {color: #006699; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #FF0000;}
.cpp.source-cpp .nu0 {color: #0000dd;}
.cpp.source-cpp .nu6 {color: #208080;}
.cpp.source-cpp .nu8 {color: #208080;}
.cpp.source-cpp .nu12 {color: #208080;}
.cpp.source-cpp .nu16 {color:#800080;}
.cpp.source-cpp .nu17 {color:#800080;}
.cpp.source-cpp .nu18 {color:#800080;}
.cpp.source-cpp .nu19 {color:#800080;}
.cpp.source-cpp .me1 {color: #007788;}
.cpp.source-cpp .me2 {color: #007788;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style><style type="text/css">/*<![CDATA[*/
.source-bash {line-height: normal;}
.source-bash li, .source-bash pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for bash
 * CSS class: source-bash, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.bash.source-bash .de1, .bash.source-bash .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.bash.source-bash  {font-family:monospace;}
.bash.source-bash .imp {font-weight: bold; color: red;}
.bash.source-bash li, .bash.source-bash .li1 {font-weight: normal; vertical-align:top;}
.bash.source-bash .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.bash.source-bash .li2 {font-weight: bold; vertical-align:top;}
.bash.source-bash .kw1 {color: #000000; font-weight: bold;}
.bash.source-bash .kw2 {color: #c20cb9; font-weight: bold;}
.bash.source-bash .kw3 {color: #7a0874; font-weight: bold;}
.bash.source-bash .co0 {color: #666666; font-style: italic;}
.bash.source-bash .co1 {color: #800000;}
.bash.source-bash .co2 {color: #cc0000; font-style: italic;}
.bash.source-bash .co3 {color: #000000; font-weight: bold;}
.bash.source-bash .es1 {color: #000099; font-weight: bold;}
.bash.source-bash .es2 {color: #007800;}
.bash.source-bash .es3 {color: #007800;}
.bash.source-bash .es4 {color: #007800;}
.bash.source-bash .es5 {color: #780078;}
.bash.source-bash .es_h {color: #000099; font-weight: bold;}
.bash.source-bash .br0 {color: #7a0874; font-weight: bold;}
.bash.source-bash .sy0 {color: #000000; font-weight: bold;}
.bash.source-bash .st0 {color: #ff0000;}
.bash.source-bash .st_h {color: #ff0000;}
.bash.source-bash .nu0 {color: #000000;}
.bash.source-bash .re0 {color: #007800;}
.bash.source-bash .re1 {color: #007800;}
.bash.source-bash .re2 {color: #007800;}
.bash.source-bash .re4 {color: #007800;}
.bash.source-bash .re5 {color: #660033;}
.bash.source-bash .ln-xtra, .bash.source-bash li.ln-xtra, .bash.source-bash div.ln-xtra {background-color: #ffc;}
.bash.source-bash span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/mediawiki/skins/vector/csshover.min.htc")}</style><![endif]--><script async="" src="./PCL_OpenNI tutorial 3_ Cloud processing (advanced) - Robótica - ULE_files/load(3).php"></script></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-PCL_OpenNI_tutorial_3_Cloud_processing_advanced skin-vector action-view vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">PCL/OpenNI tutorial 3: Cloud processing (advanced)</span></h1>
			<div id="bodyContent">
								<div id="siteSub">From Robótica - ULE</div>
								<div id="contentSub"></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#mw-navigation">navigation</a>, 					<a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><p>Go to root: <a href="http://robotica.unileon.es/mediawiki/index.php/PhD-3D-Object-Tracking" title="PhD-3D-Object-Tracking">PhD-3D-Object-Tracking</a>
</p>
<hr>
<hr>
<p><br>
Most of the techniques seen in the <a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)" title="PCL/OpenNI tutorial 2: Cloud processing (basic)"> previous tutorial</a> focused on <i>preprocessing</i>, that is, performing certain operations on the cloud to get it ready for further analysis or work. Downsampling, removing outliers, surface smoothing, estimating the normals...
</p><p>This new tutorial will teach you many interesting things that can be done with point clouds after the preparation step, such as registration, segmentation and model matching, and other advanced operations.
</p>
<div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2><span class="toctoggle">&nbsp;[<a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#" class="internal" id="togglelink">hide</a>]&nbsp;</span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#Registration"><span class="tocnumber">1</span> <span class="toctext">Registration</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#Iterative_Closest_Point_.28ICP.29"><span class="tocnumber">1.1</span> <span class="toctext">Iterative Closest Point (ICP)</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-3"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#Model_fitting_.28RANSAC.29"><span class="tocnumber">2</span> <span class="toctext">Model fitting (RANSAC)</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#Projecting_points"><span class="tocnumber">2.1</span> <span class="toctext">Projecting points</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-5"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#Segmentation"><span class="tocnumber">3</span> <span class="toctext">Segmentation</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#Euclidean"><span class="tocnumber">3.1</span> <span class="toctext">Euclidean</span></a>
<ul>
<li class="toclevel-3 tocsection-7"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#Conditional"><span class="tocnumber">3.1.1</span> <span class="toctext">Conditional</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-8"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#Region_growing"><span class="tocnumber">3.2</span> <span class="toctext">Region growing</span></a>
<ul>
<li class="toclevel-3 tocsection-9"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#Color-based"><span class="tocnumber">3.2.1</span> <span class="toctext">Color-based</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-10"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#Min-Cut"><span class="tocnumber">3.3</span> <span class="toctext">Min-Cut</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#RANSAC"><span class="tocnumber">3.4</span> <span class="toctext">RANSAC</span></a>
<ul>
<li class="toclevel-3 tocsection-12"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#Plane_model"><span class="tocnumber">3.4.1</span> <span class="toctext">Plane model</span></a></li>
<li class="toclevel-3 tocsection-13"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#Cylinder_model"><span class="tocnumber">3.4.2</span> <span class="toctext">Cylinder model</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-14"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#Retrieving_the_hull"><span class="tocnumber">4</span> <span class="toctext">Retrieving the hull</span></a>
<ul>
<li class="toclevel-2 tocsection-15"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#Concave_hull"><span class="tocnumber">4.1</span> <span class="toctext">Concave hull</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#Convex_hull"><span class="tocnumber">4.2</span> <span class="toctext">Convex hull</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-17"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#Reconstruction"><span class="tocnumber">5</span> <span class="toctext">Reconstruction</span></a>
<ul>
<li class="toclevel-2 tocsection-18"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#Triangulation"><span class="tocnumber">5.1</span> <span class="toctext">Triangulation</span></a></li>
</ul>
</li>
</ul>
</div>

<h1><span class="mw-headline" id="Registration">Registration</span></h1>
<p><i>Registration</i> is the technique of aligning two point clouds, like pieces of a puzzle. To be precise, the algorithm finds a set of correspondences between them, which would mean that there is an area of the scene that has been captured in both clouds. A <i>linear transformation</i> is then computed, which outputs a matrix that contains a rotation and a translation. These are the operations that you would apply to one of the clouds so it would get in place with respect to the other, with the intersecting areas overlapping.
</p><p>The best results are achieved with clouds that are very similar, so you should try to minimize the transformations between them. Meaning, do not run like crazy with a Kinect in your hands, grabbing frames, and expect PCL to match the clouds. It is better to move the sensor gingerly and at steady intervals. If you use a robotic arm or a rotating tabletop with precise angles, even better.
</p><p>Registration is a very useful technique because it lets you retrieve full, complete and continous <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/in_hand_scanner.php">models</a> of a scene or object. It is also expensive for the CPU. Optimizations have been developed that allow to do cloud matching in real time with the GPU, like <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/using_kinfu_large_scale.php">KinFu</a> does.
</p><p><br>
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:652px;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:Pairwise_registration.jpg" class="image"><img alt="" src="./PCL_OpenNI tutorial 3_ Cloud processing (advanced) - Robótica - ULE_files/Pairwise_registration.jpg" width="650" height="554" class="thumbimage"></a>  <div class="thumbcaption"><div class="magnify"><a href="http://robotica.unileon.es/mediawiki/index.php/File:Pairwise_registration.jpg" class="internal" title="Enlarge"><img src="./PCL_OpenNI tutorial 3_ Cloud processing (advanced) - Robótica - ULE_files/magnify-clip.png" width="15" height="11" alt=""></a></div>Flowchart diagram showing an iteration of the registration algorithm (image from <a rel="nofollow" class="external free" href="http://pointclouds.org/">http://pointclouds.org/</a>).</div></div></div></div>
<p><br>
The previous diagram illustrates how the procedure is done. There are mainly two different methods to choose from:
</p>
<ul>
<li> <b>ICP registration</b>: ICP stands for <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Iterative_closest_point">Iterative Closest Point</a>. It is an algorithm that will find the best transformation that minimizes the distance from the source point cloud to the target one. The problem is that it will do it by associating every point of the source cloud to its "twin" in the target cloud in a linear way, so it can be considered a brute force method. It the clouds are too big, the algorithm will take its time to finish, so try downsampling them first.
</li>
<li> <b>Feature-based registration</b>: the algorithm finds a set of keypoints in each cloud, computes a local descriptor for each (we explain what local descriptors are in <a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_4:_3D_object_recognition_(descriptors)" title="PCL/OpenNI tutorial 4: 3D object recognition (descriptors)">the next tutorial</a>; they are like individual signatures of points), and then performs a search to see if the clouds have keypoints in common. If at least 3 correspondences are found, a transformation can be computed. For accurate results, several correspondences must be found. This method is (or should be) faster than the first, because matching is only done for the keypoints, not the whole cloud.
</li>
</ul>
<p>ICP will probably fail if the difference between the clouds is too big. Usually, you will use features first to perform an initial rough alignment of the clouds, and then use ICP to refine it with precision. Feature-based registration is basically identical to the <a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_5:_3D_object_recognition_(pipeline)" title="PCL/OpenNI tutorial 5: 3D object recognition (pipeline)">3D object recognition problem</a>, so we will not look into it here. Features, descriptors and recognition will be dealt with in the next tutorials.
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Tutorials</b>:
<ul>
<li> <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/registration_api.php">The PCL Registration API</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://www.pointclouds.org/assets/icra2013/Miller_presentation_ICRA13.pdf">Clean Models from Noisy Sensors: Registration and Reconstruction Techniques</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://www.pointclouds.org/assets/icra2013/registration.pdf">3D Registration with PCL</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://www.pointclouds.org/assets/uploads/PCL-IAS13_Registration.pdf">Point Cloud Registration</a>
</li>
</ul>
</li>
</ul>
</div>
<p><br>
</p>
<h2><span class="mw-headline" id="Iterative_Closest_Point_.28ICP.29">Iterative Closest Point (ICP)</span></h2>
<p>PCL offers several implementations of the ICP algorithm. We will see the general, unoptimized one, but you may want to try one of the optimized variants listed below in the API section. The code for aligning (registering) two point clouds is the following:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/registration/icp.h&gt;</span>
&nbsp;
<span class="co2">#include &lt;iostream&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Objects for storing the point clouds.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> sourceCloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> targetCloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> finalCloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read two PCD files from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>sourceCloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>2<span class="br0">]</span>, <span class="sy2">*</span>targetCloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// ICP object.</span>
	pcl<span class="sy4">::</span><span class="me2">IterativeClosestPoint</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span>, pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> registration<span class="sy4">;</span>
	registration.<span class="me1">setInputSource</span><span class="br0">(</span>sourceCloud<span class="br0">)</span><span class="sy4">;</span>
	registration.<span class="me1">setInputTarget</span><span class="br0">(</span>targetCloud<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	registration.<span class="me1">align</span><span class="br0">(</span><span class="sy2">*</span>finalCloud<span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">(</span>registration.<span class="me1">hasConverged</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
	<span class="br0">{</span>
		std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"ICP converged."</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span>
				  <span class="sy1">&lt;&lt;</span> <span class="st0">"The score is "</span> <span class="sy1">&lt;&lt;</span> registration.<span class="me1">getFitnessScore</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
		std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"Transformation matrix:"</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
		std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> registration.<span class="me1">getFinalTransformation</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
	<span class="br0">}</span>
	<span class="kw1">else</span> std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"ICP did not converge."</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>The cloud saved in <span style="color:#FF1493">"finalCloud"</span> is the same as <span style="color:#FF1493">"sourceCloud"</span> (it has the same points), but the transformation found by ICP has been applied, so when visualized next to <span style="color:#FF1493">"targetCloud"</span> they should match properly (errors are inevitable and depend of many factors, like the quality of the sensor, the distance between the clouds, the algorithm used...).
</p><p><br>
</p>
<center><ul class="gallery mw-gallery-traditional">
		<li class="gallerybox" style="width: 335px"><div style="width: 335px">
			<div class="thumb" style="width: 330px;"><div style="margin:15px auto;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:Registration_cloud1.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 3_ Cloud processing (advanced) - Robótica - ULE_files/Registration_cloud1.png" width="156" height="120"></a></div></div>
			<div class="gallerytext">
<p>Source point cloud.
</p>
			</div>
		</div></li>
		<li class="gallerybox" style="width: 335px"><div style="width: 335px">
			<div class="thumb" style="width: 330px;"><div style="margin:15px auto;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:Registration_cloud2.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 3_ Cloud processing (advanced) - Robótica - ULE_files/Registration_cloud2.png" width="156" height="120"></a></div></div>
			<div class="gallerytext">
<p>Target point cloud.
</p>
			</div>
		</div></li>
		<li class="gallerybox" style="width: 335px"><div style="width: 335px">
			<div class="thumb" style="width: 330px;"><div style="margin:15px auto;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:Registration_before.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 3_ Cloud processing (advanced) - Robótica - ULE_files/Registration_before.png" width="156" height="120"></a></div></div>
			<div class="gallerytext">
<p>Both clouds shown together before registration.
</p>
			</div>
		</div></li>
		<li class="gallerybox" style="width: 335px"><div style="width: 335px">
			<div class="thumb" style="width: 330px;"><div style="margin:15px auto;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:Registration_after.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 3_ Cloud processing (advanced) - Robótica - ULE_files/Registration_after.png" width="156" height="120"></a></div></div>
			<div class="gallerytext">
<p>Both clouds shown together after registration.
</p>
			</div>
		</div></li>
</ul></center>
<p><br>
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Source cloud, Target cloud
</li>
<li> <b>Output</b>: Registered source cloud, Transformation matrix
</li>
<li> <b>Tutorials</b>:
<ul>
<li> <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/iterative_closest_point.php">How to use iterative closest point</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/pairwise_incremental_registration.php">How to incrementally register pairs of clouds</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/interactive_icp.php">Interactive Iterative Closest Point</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/normal_distributions_transform.php">How to use Normal Distributions Transform</a>
</li>
</ul>
</li>
<li> <b>API</b>:
<ul>
<li> <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_iterative_closest_point.html">pcl::IterativeClosestPoint</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_iterative_closest_point_with_normals.html">pcl::IterativeClosestPointWithNormals</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_iterative_closest_point_non_linear.html">pcl::IterativeClosestPointNonLinear</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_joint_iterative_closest_point.html">pcl::JointIterativeClosestPoint</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_normal_distributions_transform.html">pcl::NormalDistributionsTransform</a>
</li>
</ul>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_registration.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h1><span class="mw-headline" id="Model_fitting_.28RANSAC.29">Model fitting (RANSAC)</span></h1>
<p>Given a set of data, it is possible to determine if a part of it fits a certain mathematical model, using an iterative method known as <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/RANSAC">RANSAC (Random Sample Consensus)</a>. RANSAC works under the assumption that the data contains <i>inliers</i> (data can can be adjusted to the model, even with a little noise) and <i>outliers</i> (data that does not fit the model at all). The algoritm is non-deterministic: every iteration, the accuracy of the result improves. To be precise, the probability of the result being the correct one increases, though it will never be of 100%.
</p><p><br>
</p>
<center><ul class="gallery mw-gallery-traditional">
		<li class="gallerybox" style="width: 335px"><div style="width: 335px">
			<div class="thumb" style="width: 330px;"><div style="margin:15px auto;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:RANSAC_before.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 3_ Cloud processing (advanced) - Robótica - ULE_files/RANSAC_before.png" width="120" height="120"></a></div></div>
			<div class="gallerytext">
<p>Set of data points containing outliers and inliers fitting a line model (image from Wikimedia Commons).
</p>
			</div>
		</div></li>
		<li class="gallerybox" style="width: 335px"><div style="width: 335px">
			<div class="thumb" style="width: 330px;"><div style="margin:15px auto;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:RANSAC_after.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 3_ Cloud processing (advanced) - Robótica - ULE_files/RANSAC_after.png" width="120" height="120"></a></div></div>
			<div class="gallerytext">
<p>The same set, after applying RANSAC to find the parameters of the line model, discarding outliers (image from Wikimedia Commons).
</p>
			</div>
		</div></li>
</ul></center>
<p><br>
PCL offers implementations of RANSAC to work with point clouds. For example, you can find which points in the cloud fit the model of a sphere, and the procedure will return the parameters of said model. This is how you would do it:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/sample_consensus/ransac.h&gt;</span>
<span class="co2">#include &lt;pcl/sample_consensus/sac_model_sphere.h&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Objects for storing the point clouds.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> inlierPoints<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// RANSAC objects: model and algorithm.</span>
	pcl<span class="sy4">::</span><span class="me2">SampleConsensusModelSphere</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> model<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">SampleConsensusModelSphere</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">RandomSampleConsensus</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> ransac<span class="br0">(</span>model<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Set the maximum allowed distance to the model.</span>
	ransac.<span class="me1">setDistanceThreshold</span><span class="br0">(</span>0.01<span class="br0">)</span><span class="sy4">;</span>
	ransac.<span class="me1">computeModel</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> inlierIndices<span class="sy4">;</span>
	ransac.<span class="me1">getInliers</span><span class="br0">(</span>inlierIndices<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Copy all inliers of the model to another cloud.</span>
	pcl<span class="sy4">::</span><span class="me2">copyPointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span><span class="sy2">*</span>cloud, inlierIndices, <span class="sy2">*</span>inlierPoints<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>There are many more models to choose from. The most important ones are:
</p>
<ul>
<li> <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_sample_consensus_model_circle2_d.html">pcl::SampleConsensusModelCircle2D</a>: A 2D circle on the X-Y plane.
</li>
<li> <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_sample_consensus_model_circle3_d.html">pcl::SampleConsensusModelCircle3D</a>: A 3D circle (any plane).
</li>
<li> <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_sample_consensus_model_cone.html">pcl::SampleConsensusModelCone</a>: A cone.
</li>
<li> <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_sample_consensus_model_cylinder.html">pcl::SampleConsensusModelCylinder</a>: A cylinder.
</li>
<li> <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_sample_consensus_model_line.html">pcl::SampleConsensusModelLine</a>: A line.
</li>
<li> <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_sample_consensus_model_plane.html">pcl::SampleConsensusModelPlane</a>: A plane.
</li>
<li> <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_sample_consensus_model_sphere.html">pcl::SampleConsensusModelSphere</a>: A sphere.
</li>
<li> <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_sample_consensus_model_stick.html">pcl::SampleConsensusModelStick</a>: A stick (a line with user-given minimum/maximum width).
</li>
</ul>
<p>Also, the RANSAC class offers some functions to configure its behavior. For example, with <span style="color:#FF1493">"setMaxIterations()"</span> you can specify the maximum number of iterations the algoritm will run for, instead of using a distance threshold (if you do not set a stop condition, RANSAC will just run forever, getting a slightly better result each time).
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Model, Model threshold
</li>
<li> <b>Output</b>: Vector of Point indices (inliers)
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/random_sample_consensus.php">How to use Random Sample Consensus model</a>
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_random_sample_consensus.html">pcl::RandomSampleConsensus</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_sphere_model.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h2><span class="mw-headline" id="Projecting_points">Projecting points</span></h2>
<p>After you have recovered the coefficients of a model, it is possible to project the points of a cloud onto said model. For example, if the model is a plane, after projection the points of the cloud would all lie on the plane.
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/sample_consensus/method_types.h&gt;</span>
<span class="co2">#include &lt;pcl/sample_consensus/model_types.h&gt;</span>
<span class="co2">#include &lt;pcl/segmentation/sac_segmentation.h&gt;</span>
<span class="co2">#include &lt;pcl/filters/extract_indices.h&gt;</span>
<span class="co2">#include &lt;pcl/filters/project_inliers.h&gt;</span>
<span class="co2">#include &lt;pcl/visualization/cloud_viewer.h&gt;</span>
&nbsp;
<span class="co2">#include &lt;iostream&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Objects for storing the point clouds.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloudNoPlane<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> planePoints<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> projectedPoints<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Get the plane model, if present.</span>
	pcl<span class="sy4">::</span><span class="me2">ModelCoefficients</span><span class="sy4">::</span><span class="me2">Ptr</span> coefficients<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">ModelCoefficients</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">SACSegmentation</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> segmentation<span class="sy4">;</span>
	segmentation.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
	segmentation.<span class="me1">setModelType</span><span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">SACMODEL_PLANE</span><span class="br0">)</span><span class="sy4">;</span>
	segmentation.<span class="me1">setMethodType</span><span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">SAC_RANSAC</span><span class="br0">)</span><span class="sy4">;</span>
	segmentation.<span class="me1">setDistanceThreshold</span><span class="br0">(</span>0.01<span class="br0">)</span><span class="sy4">;</span>
	segmentation.<span class="me1">setOptimizeCoefficients</span><span class="br0">(</span><span class="kw2">true</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointIndices</span><span class="sy4">::</span><span class="me2">Ptr</span> inlierIndices<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointIndices</span><span class="br0">)</span><span class="sy4">;</span>
	segmentation.<span class="me1">segment</span><span class="br0">(</span><span class="sy2">*</span>inlierIndices, <span class="sy2">*</span>coefficients<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="kw1">if</span> <span class="br0">(</span>inlierIndices<span class="sy2">-</span><span class="sy1">&gt;</span>indices.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">==</span> 0<span class="br0">)</span>
		std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"Could not find a plane in the scene."</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
	<span class="kw1">else</span>
	<span class="br0">{</span>
		std<span class="sy4">::</span><span class="kw3">cerr</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"Plane coefficients: "</span> <span class="sy1">&lt;&lt;</span> coefficients<span class="sy2">-</span><span class="sy1">&gt;</span>values<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy1">&lt;&lt;</span> <span class="st0">" "</span>
				  <span class="sy1">&lt;&lt;</span> coefficients<span class="sy2">-</span><span class="sy1">&gt;</span>values<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy1">&lt;&lt;</span> <span class="st0">" "</span>
				  <span class="sy1">&lt;&lt;</span> coefficients<span class="sy2">-</span><span class="sy1">&gt;</span>values<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy1">&lt;&lt;</span> <span class="st0">" "</span>
				  <span class="sy1">&lt;&lt;</span> coefficients<span class="sy2">-</span><span class="sy1">&gt;</span>values<span class="br0">[</span>3<span class="br0">]</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
&nbsp;
		<span class="co1">// Create a second point cloud that does not have the plane points.</span>
		<span class="co1">// Also, extract the plane points to visualize them later.</span>
		pcl<span class="sy4">::</span><span class="me2">ExtractIndices</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> extract<span class="sy4">;</span>
		extract.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
		extract.<span class="me1">setIndices</span><span class="br0">(</span>inlierIndices<span class="br0">)</span><span class="sy4">;</span>
		extract.<span class="me1">filter</span><span class="br0">(</span><span class="sy2">*</span>planePoints<span class="br0">)</span><span class="sy4">;</span>
		extract.<span class="me1">setNegative</span><span class="br0">(</span><span class="kw2">true</span><span class="br0">)</span><span class="sy4">;</span>
		extract.<span class="me1">filter</span><span class="br0">(</span><span class="sy2">*</span>cloudNoPlane<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
		<span class="co1">// Object for projecting points onto a model.</span>
		pcl<span class="sy4">::</span><span class="me2">ProjectInliers</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> projection<span class="sy4">;</span>
		<span class="co1">// We have to specify what model we used.</span>
		projection.<span class="me1">setModelType</span><span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">SACMODEL_PLANE</span><span class="br0">)</span><span class="sy4">;</span>
		projection.<span class="me1">setInputCloud</span><span class="br0">(</span>cloudNoPlane<span class="br0">)</span><span class="sy4">;</span>
		<span class="co1">// And we have to give the coefficients we got.</span>
		projection.<span class="me1">setModelCoefficients</span><span class="br0">(</span>coefficients<span class="br0">)</span><span class="sy4">;</span>
		projection.<span class="me1">filter</span><span class="br0">(</span><span class="sy2">*</span>projectedPoints<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
		<span class="co1">// Visualize everything.</span>
		pcl<span class="sy4">::</span><span class="me2">visualization</span><span class="sy4">::</span><span class="me2">CloudViewer</span> viewerPlane<span class="br0">(</span><span class="st0">"Plane"</span><span class="br0">)</span><span class="sy4">;</span>
		viewerPlane.<span class="me1">showCloud</span><span class="br0">(</span>planePoints<span class="br0">)</span><span class="sy4">;</span>
		<span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span>viewerPlane.<span class="me1">wasStopped</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
		<span class="br0">{</span>
			<span class="co1">// Do nothing but wait.</span>
		<span class="br0">}</span>
		pcl<span class="sy4">::</span><span class="me2">visualization</span><span class="sy4">::</span><span class="me2">CloudViewer</span> viewerProjection<span class="br0">(</span><span class="st0">"Projected points"</span><span class="br0">)</span><span class="sy4">;</span>
		viewerProjection.<span class="me1">showCloud</span><span class="br0">(</span>projectedPoints<span class="br0">)</span><span class="sy4">;</span>
		<span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span>viewerProjection.<span class="me1">wasStopped</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
		<span class="br0">{</span>
			<span class="co1">// Do nothing but wait.</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>After running the example, you will see that all points have been "flattened" onto the plane (if there was one in the scene, that is). The program will first show you the points that have been fitted to a plane. When you quit with <span style="color:#228B22"><b>Alt+F4</b></span> or <span style="color:#228B22"><b>Q</b></span>, a second window will open displaying the results of the projection.
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Model type, Model coefficients
</li>
<li> <b>Output</b>: Projected points
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/project_inliers.php">Projecting points using a parametric model</a>
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_project_inliers.html">pcl::ProjectInliers</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_point_projection.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h1><span class="mw-headline" id="Segmentation">Segmentation</span></h1>
<p><i>Segmentation</i> consists of breaking the cloud apart in different pieces or sections: groups of points called <i>clusters</i> (which is why it is also referred to as <i>clustering</i>). The idea is to divide it in several parts to be processed independently. Ideally, every cluster would belong to the logical notion of "object". For example, for a cloud that shows 3 boxes on a table, 4 clusters would be created: one for the table, and one for each of the boxes.
</p><p>There are many segmentation techniques, each one with its own criteria for grouping points together. Some consider the distance between points, some take into account the normals, or even the texture, too. Here I will give you an overview of each one.
</p><p>Segmentation, together with all other methods seen so far, will allow you to retrieve the models of individual objects from a scene. Also, it is possible to segment certain shapes like planes or cylinders. If you need example point clouds to practice your segmentation skills with, take a look at the <a rel="nofollow" class="external text" href="http://www.acin.tuwien.ac.at/?id=289">OSD</a> (Object Segmentation Database).
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://www.pointclouds.org/assets/icra2013/pcl_organized_segmentation.pdf">Organized Point Cloud Segmentation</a>
</li>
</ul>
</div>
<p><br>
</p>
<h2><span class="mw-headline" id="Euclidean">Euclidean</span></h2>
<p>Euclidean segmentation is the simplest of all. It checks the distance between two points. If it is less than a threshold, both are considered to belong in the same cluster. It works like a <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Flood_fill">flood fill</a> algorithm: a point in the cloud is "marked" as "chosen" for the cluster. Then, it spreads like a virus to all other points that are near enough, and from those to even more points, until none new can be added. Then, a new cluster is initialized, and the procedure starts again with the remaining unmarked points.
</p><p>In PCL, Euclidean segmentation is done as follows:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/segmentation/extract_clusters.h&gt;</span>
&nbsp;
<span class="co2">#include &lt;iostream&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Object for storing the point cloud.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// kd-tree object for searches.</span>
	pcl<span class="sy4">::</span><span class="me2">search</span><span class="sy4">::</span><span class="me2">KdTree</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> kdtree<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">search</span><span class="sy4">::</span><span class="me2">KdTree</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	kdtree<span class="sy2">-</span><span class="sy1">&gt;</span>setInputCloud<span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Euclidean clustering object.</span>
	pcl<span class="sy4">::</span><span class="me2">EuclideanClusterExtraction</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> clustering<span class="sy4">;</span>
	<span class="co1">// Set cluster tolerance to 2cm (small values may cause objects to be divided</span>
	<span class="co1">// in several clusters, whereas big values may join objects in a same cluster).</span>
	clustering.<span class="me1">setClusterTolerance</span><span class="br0">(</span>0.02<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Set the minimum and maximum number of points that a cluster can have.</span>
	clustering.<span class="me1">setMinClusterSize</span><span class="br0">(</span>100<span class="br0">)</span><span class="sy4">;</span>
	clustering.<span class="me1">setMaxClusterSize</span><span class="br0">(</span>25000<span class="br0">)</span><span class="sy4">;</span>
	clustering.<span class="me1">setSearchMethod</span><span class="br0">(</span>kdtree<span class="br0">)</span><span class="sy4">;</span>
	clustering.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
	std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointIndices</span><span class="sy1">&gt;</span> clusters<span class="sy4">;</span>
	clustering.<span class="me1">extract</span><span class="br0">(</span>clusters<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// For every cluster...</span>
	<span class="kw4">int</span> currentClusterNum <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">(</span>std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointIndices</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_iterator</span> i <span class="sy1">=</span> clusters.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> i <span class="sy3">!</span><span class="sy1">=</span> clusters.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="co1">// ...add all its points to a new cloud...</span>
		pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cluster<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">(</span>std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_iterator</span> point <span class="sy1">=</span> i<span class="sy2">-</span><span class="sy1">&gt;</span>indices.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> point <span class="sy3">!</span><span class="sy1">=</span> i<span class="sy2">-</span><span class="sy1">&gt;</span>indices.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> point<span class="sy2">++</span><span class="br0">)</span>
			cluster<span class="sy2">-</span><span class="sy1">&gt;</span>points.<span class="me1">push_back</span><span class="br0">(</span>cloud<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span><span class="sy2">*</span>point<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
		cluster<span class="sy2">-</span><span class="sy1">&gt;</span>width <span class="sy1">=</span> cluster<span class="sy2">-</span><span class="sy1">&gt;</span>points.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
		cluster<span class="sy2">-</span><span class="sy1">&gt;</span>height <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
		cluster<span class="sy2">-</span><span class="sy1">&gt;</span>is_dense <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
&nbsp;
		<span class="co1">// ...and save it to disk.</span>
		<span class="kw1">if</span> <span class="br0">(</span>cluster<span class="sy2">-</span><span class="sy1">&gt;</span>points.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">&lt;=</span> 0<span class="br0">)</span>
			<span class="kw1">break</span><span class="sy4">;</span>
		std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"Cluster "</span> <span class="sy1">&lt;&lt;</span> currentClusterNum <span class="sy1">&lt;&lt;</span> <span class="st0">" has "</span> <span class="sy1">&lt;&lt;</span> cluster<span class="sy2">-</span><span class="sy1">&gt;</span>points.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">&lt;&lt;</span> <span class="st0">" points."</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
		std<span class="sy4">::</span><span class="me2">string</span> fileName <span class="sy1">=</span> <span class="st0">"cluster"</span> <span class="sy2">+</span> boost<span class="sy4">::</span><span class="me2">to_string</span><span class="br0">(</span>currentClusterNum<span class="br0">)</span> <span class="sy2">+</span> <span class="st0">".pcd"</span><span class="sy4">;</span>
		pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">savePCDFileASCII</span><span class="br0">(</span>fileName, <span class="sy2">*</span>cluster<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
		currentClusterNum<span class="sy2">++</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>You may have to play with the cluster tolerance parameter until you get good results. Also, it is recommended to perform planar segmentation (we will see it later) to remove the floor and/or table(s) from the scene, or the results may be wrong.
</p><p>After the program finishes, you can visualize all clusters at the same time with:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="bash source-bash" style="font-family:monospace;"><pre class="de1">pcl_viewer cluster<span class="sy0">*</span></pre></div></div>
<p><br>
</p>
<center><ul class="gallery mw-gallery-traditional">
		<li class="gallerybox" style="width: 335px"><div style="width: 335px">
			<div class="thumb" style="width: 330px;"><div style="margin:15px auto;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:EuclideanClusteringBefore.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 3_ Cloud processing (advanced) - Robótica - ULE_files/EuclideanClusteringBefore.png" width="156" height="120"></a></div></div>
			<div class="gallerytext">
<p>Original cloud.
</p>
			</div>
		</div></li>
		<li class="gallerybox" style="width: 335px"><div style="width: 335px">
			<div class="thumb" style="width: 330px;"><div style="margin:15px auto;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:EuclideanClusteringAfter.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 3_ Cloud processing (advanced) - Robótica - ULE_files/EuclideanClusteringAfter.png" width="156" height="120"></a></div></div>
			<div class="gallerytext">
<p>Clusters recovered after Euclidean segmentation (each cluster is renderer with a different color).
</p>
			</div>
		</div></li>
</ul></center>
<p><br>
All segmentation objects provide a <span style="color:#FF1493">"setIndices()"</span> function. You can use it to provide the indices of the points you want to apply clustering to, instead of the whole cloud.
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Cluster tolerance, Minimum cluster size, Maximum cluster size, Search method, [Indices]
</li>
<li> <b>Output</b>: Vector of Point indices (clusters)
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/cluster_extraction.php">Euclidean Cluster Extraction</a>
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_euclidean_cluster_extraction.html">pcl::EuclideanClusterExtraction</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_euclidean_clustering.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h3><span class="mw-headline" id="Conditional">Conditional</span></h3>
<p>Conditional Euclidean segmentation works the same way as the standard one seen above, with one exception. Apart from the distance check, points need also to meet a special, custom requirement for them to be added to a cluster. This condition is user-specified. It boils down to this: for every pair of points (the first one, the <i>seed</i>, is being processed in this moment, the second one, <i>candidate</i>, is a neighbor of the former that is being tested) a custom function will be called. This function has a certain signature: it receives
</p>
<ol>
<li> a copy of the two points so we can perform our own tests, and
</li>
<li> the squared distance
</li>
</ol>
<p>and returns a boolean value. If the value is true, the candidate may be added to the cluster. If false, it will not, even if it passed the distance check.
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/segmentation/conditional_euclidean_clustering.h&gt;</span>
&nbsp;
<span class="co2">#include &lt;iostream&gt;</span>
&nbsp;
<span class="co1">// If this function returns true, the candidate point will be added</span>
<span class="co1">// to the cluster of the seed point.</span>
<span class="kw4">bool</span>
customCondition<span class="br0">(</span><span class="kw4">const</span> pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy3">&amp;</span> seedPoint, <span class="kw4">const</span> pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy3">&amp;</span> candidatePoint, <span class="kw4">float</span> squaredDistance<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Do whatever you want here.</span>
	<span class="kw1">if</span> <span class="br0">(</span>candidatePoint.<span class="me1">y</span> <span class="sy1">&lt;</span> seedPoint.<span class="me1">y</span><span class="br0">)</span>
		<span class="kw1">return</span> <span class="kw2">false</span><span class="sy4">;</span>
&nbsp;
	<span class="kw1">return</span> <span class="kw2">true</span><span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Object for storing the point cloud.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Conditional Euclidean clustering object.</span>
	pcl<span class="sy4">::</span><span class="me2">ConditionalEuclideanClustering</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> clustering<span class="sy4">;</span>
	clustering.<span class="me1">setClusterTolerance</span><span class="br0">(</span>0.02<span class="br0">)</span><span class="sy4">;</span>
	clustering.<span class="me1">setMinClusterSize</span><span class="br0">(</span>100<span class="br0">)</span><span class="sy4">;</span>
	clustering.<span class="me1">setMaxClusterSize</span><span class="br0">(</span>25000<span class="br0">)</span><span class="sy4">;</span>
	clustering.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Set the function that will be called for every pair of points to check.</span>
	clustering.<span class="me1">setConditionFunction</span><span class="br0">(</span><span class="sy3">&amp;</span>customCondition<span class="br0">)</span><span class="sy4">;</span>
	std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointIndices</span><span class="sy1">&gt;</span> clusters<span class="sy4">;</span>
	clustering.<span class="me1">segment</span><span class="br0">(</span>clusters<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// For every cluster...</span>
	<span class="kw4">int</span> currentClusterNum <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">(</span>std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointIndices</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_iterator</span> i <span class="sy1">=</span> clusters.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> i <span class="sy3">!</span><span class="sy1">=</span> clusters.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="co1">// ...add all its points to a new cloud...</span>
		pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cluster<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">(</span>std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_iterator</span> point <span class="sy1">=</span> i<span class="sy2">-</span><span class="sy1">&gt;</span>indices.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> point <span class="sy3">!</span><span class="sy1">=</span> i<span class="sy2">-</span><span class="sy1">&gt;</span>indices.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> point<span class="sy2">++</span><span class="br0">)</span>
			cluster<span class="sy2">-</span><span class="sy1">&gt;</span>points.<span class="me1">push_back</span><span class="br0">(</span>cloud<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span><span class="sy2">*</span>point<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
		cluster<span class="sy2">-</span><span class="sy1">&gt;</span>width <span class="sy1">=</span> cluster<span class="sy2">-</span><span class="sy1">&gt;</span>points.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
		cluster<span class="sy2">-</span><span class="sy1">&gt;</span>height <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
		cluster<span class="sy2">-</span><span class="sy1">&gt;</span>is_dense <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
&nbsp;
		<span class="co1">// ...and save it to disk.</span>
		<span class="kw1">if</span> <span class="br0">(</span>cluster<span class="sy2">-</span><span class="sy1">&gt;</span>points.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">&lt;=</span> 0<span class="br0">)</span>
			<span class="kw1">break</span><span class="sy4">;</span>
		std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"Cluster "</span> <span class="sy1">&lt;&lt;</span> currentClusterNum <span class="sy1">&lt;&lt;</span> <span class="st0">" has "</span> <span class="sy1">&lt;&lt;</span> cluster<span class="sy2">-</span><span class="sy1">&gt;</span>points.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">&lt;&lt;</span> <span class="st0">" points."</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
		std<span class="sy4">::</span><span class="me2">string</span> fileName <span class="sy1">=</span> <span class="st0">"cluster"</span> <span class="sy2">+</span> boost<span class="sy4">::</span><span class="me2">to_string</span><span class="br0">(</span>currentClusterNum<span class="br0">)</span> <span class="sy2">+</span> <span class="st0">".pcd"</span><span class="sy4">;</span>
		pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">savePCDFileASCII</span><span class="br0">(</span>fileName, <span class="sy2">*</span>cluster<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
		currentClusterNum<span class="sy2">++</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>The condition that is implemented above (checking if the candidate's Y coordinate is lower than the seed's) does not make a lot of sense, but I just wanted you to understand how the method works.
</p><p>If you pass <span style="color:#FF1493">"true"</span> to the constructor of <span style="color:#FF1493">"pcl::ConditionalEuclideanClustering"</span>, the object will store the clusters that were discarded for being too small or too big. You can later retrieve them with the <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_conditional_euclidean_clustering.html#af264099e843fbf5d48049857e1e1d6af">getRemovedClusters()</a> function.
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Cluster tolerance, Minimum cluster size, Maximum cluster size, Search method, Custom check function, [Indices]
</li>
<li> <b>Output</b>: Vector of Point indices (clusters)
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/conditional_euclidean_clustering.php">Conditional Euclidean Clustering</a>
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_conditional_euclidean_clustering.html">pcl::ConditionalEuclideanClustering</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_conditional_euclidean_clustering.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h2><span class="mw-headline" id="Region_growing">Region growing</span></h2>
<p>This type of segmentation (which is also a greedy-like, flood fill approach like the Euclidean one) groups together points that check a smoothness constraint. The angle between their normals and the difference of curvatures are checked to see if they could belong to the same smooth surface. Think about a box laying on a table: with Euclidean segmentation, both would be considered to be in the same cluster because they are "touching". With region growing segmentation, this would not happen, because there is a 90° (with ideal normal estimation, that is) difference between the normals of a point in the table and another one in the box's lateral.
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/search/kdtree.h&gt;</span>
<span class="co2">#include &lt;pcl/features/normal_3d.h&gt;</span>
<span class="co2">#include &lt;pcl/segmentation/region_growing.h&gt;</span>
&nbsp;
<span class="co2">#include &lt;iostream&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Object for storing the point cloud.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Object for storing the normals.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">Normal</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> normals<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">Normal</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// kd-tree object for searches.</span>
	pcl<span class="sy4">::</span><span class="me2">search</span><span class="sy4">::</span><span class="me2">KdTree</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> kdtree<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">search</span><span class="sy4">::</span><span class="me2">KdTree</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	kdtree<span class="sy2">-</span><span class="sy1">&gt;</span>setInputCloud<span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Estimate the normals.</span>
	pcl<span class="sy4">::</span><span class="me2">NormalEstimation</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span>, pcl<span class="sy4">::</span><span class="me2">Normal</span><span class="sy1">&gt;</span> normalEstimation<span class="sy4">;</span>
	normalEstimation.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
	normalEstimation.<span class="me1">setRadiusSearch</span><span class="br0">(</span>0.03<span class="br0">)</span><span class="sy4">;</span>
	normalEstimation.<span class="me1">setSearchMethod</span><span class="br0">(</span>kdtree<span class="br0">)</span><span class="sy4">;</span>
	normalEstimation.<span class="me1">compute</span><span class="br0">(</span><span class="sy2">*</span>normals<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Region growing clustering object.</span>
	pcl<span class="sy4">::</span><span class="me2">RegionGrowing</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span>, pcl<span class="sy4">::</span><span class="me2">Normal</span><span class="sy1">&gt;</span> clustering<span class="sy4">;</span>
	clustering.<span class="me1">setMinClusterSize</span><span class="br0">(</span>100<span class="br0">)</span><span class="sy4">;</span>
	clustering.<span class="me1">setMaxClusterSize</span><span class="br0">(</span>10000<span class="br0">)</span><span class="sy4">;</span>
	clustering.<span class="me1">setSearchMethod</span><span class="br0">(</span>kdtree<span class="br0">)</span><span class="sy4">;</span>
	clustering.<span class="me1">setNumberOfNeighbours</span><span class="br0">(</span>30<span class="br0">)</span><span class="sy4">;</span>
	clustering.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
	clustering.<span class="me1">setInputNormals</span><span class="br0">(</span>normals<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Set the angle in radians that will be the smoothness threshold</span>
	<span class="co1">// (the maximum allowable deviation of the normals).</span>
	clustering.<span class="me1">setSmoothnessThreshold</span><span class="br0">(</span>7.0 <span class="sy2">/</span> 180.0 <span class="sy2">*</span> M_PI<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 7 degrees.</span>
	<span class="co1">// Set the curvature threshold. The disparity between curvatures will be</span>
	<span class="co1">// tested after the normal deviation check has passed.</span>
	clustering.<span class="me1">setCurvatureThreshold</span><span class="br0">(</span>1.0<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	std<span class="sy4">::</span><span class="me2">vector</span> <span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointIndices</span><span class="sy1">&gt;</span> clusters<span class="sy4">;</span>
	clustering.<span class="me1">extract</span><span class="br0">(</span>clusters<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// For every cluster...</span>
	<span class="kw4">int</span> currentClusterNum <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">(</span>std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointIndices</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_iterator</span> i <span class="sy1">=</span> clusters.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> i <span class="sy3">!</span><span class="sy1">=</span> clusters.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="co1">// ...add all its points to a new cloud...</span>
		pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cluster<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">(</span>std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_iterator</span> point <span class="sy1">=</span> i<span class="sy2">-</span><span class="sy1">&gt;</span>indices.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> point <span class="sy3">!</span><span class="sy1">=</span> i<span class="sy2">-</span><span class="sy1">&gt;</span>indices.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> point<span class="sy2">++</span><span class="br0">)</span>
			cluster<span class="sy2">-</span><span class="sy1">&gt;</span>points.<span class="me1">push_back</span><span class="br0">(</span>cloud<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span><span class="sy2">*</span>point<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
		cluster<span class="sy2">-</span><span class="sy1">&gt;</span>width <span class="sy1">=</span> cluster<span class="sy2">-</span><span class="sy1">&gt;</span>points.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
		cluster<span class="sy2">-</span><span class="sy1">&gt;</span>height <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
		cluster<span class="sy2">-</span><span class="sy1">&gt;</span>is_dense <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
&nbsp;
		<span class="co1">// ...and save it to disk.</span>
		<span class="kw1">if</span> <span class="br0">(</span>cluster<span class="sy2">-</span><span class="sy1">&gt;</span>points.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">&lt;=</span> 0<span class="br0">)</span>
			<span class="kw1">break</span><span class="sy4">;</span>
		std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"Cluster "</span> <span class="sy1">&lt;&lt;</span> currentClusterNum <span class="sy1">&lt;&lt;</span> <span class="st0">" has "</span> <span class="sy1">&lt;&lt;</span> cluster<span class="sy2">-</span><span class="sy1">&gt;</span>points.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">&lt;&lt;</span> <span class="st0">" points."</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
		std<span class="sy4">::</span><span class="me2">string</span> fileName <span class="sy1">=</span> <span class="st0">"cluster"</span> <span class="sy2">+</span> boost<span class="sy4">::</span><span class="me2">to_string</span><span class="br0">(</span>currentClusterNum<span class="br0">)</span> <span class="sy2">+</span> <span class="st0">".pcd"</span><span class="sy4">;</span>
		pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">savePCDFileASCII</span><span class="br0">(</span>fileName, <span class="sy2">*</span>cluster<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
		currentClusterNum<span class="sy2">++</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Minimum cluster size, Maximum cluster size, Neighbor count, Search method, Normals, Smoothness threshold, Curvature threshold, [Indices]
</li>
<li> <b>Output</b>: Vector of Point indices (clusters)
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/region_growing_segmentation.php">Region growing segmentation</a>
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_region_growing.html">pcl::RegionGrowing</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_region_growing_clustering.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h3><span class="mw-headline" id="Color-based">Color-based</span></h3>
<p>This method is based on the previous one but, instead of comparing the normals and the curvature of the points, it compares the RGB color. Like always, if the difference is less than a threshold, both are put in the same cluster. Obviously, for this to work you need a cloud with RGB information (with the type <span style="color:#FF1493">"PointXYZRGB"</span>). You can use the <a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_1:_Installing_and_testing#Testing_.28OpenNI_viewer.29" title="PCL/OpenNI tutorial 1: Installing and testing"> OpenNI viewer</a> program to retrieve them with the Kinect or Xtion.
</p><p>Apart from the color check, this algorithm also uses two postprocessing steps. In the first one, neighboring clusters with similar average color are merged (this is controlled with a threshold, too). In the second one, clusters that are smaller than the minimum size are merged with their neighbors.
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/search/kdtree.h&gt;</span>
<span class="co2">#include &lt;pcl/segmentation/region_growing_rgb.h&gt;</span>
&nbsp;
<span class="co2">#include &lt;iostream&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Object for storing the point cloud, with color information.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZRGB</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZRGB</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZRGB</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// kd-tree object for searches.</span>
	pcl<span class="sy4">::</span><span class="me2">search</span><span class="sy4">::</span><span class="me2">KdTree</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZRGB</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> kdtree<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">search</span><span class="sy4">::</span><span class="me2">KdTree</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZRGB</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	kdtree<span class="sy2">-</span><span class="sy1">&gt;</span>setInputCloud<span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Color-based region growing clustering object.</span>
	pcl<span class="sy4">::</span><span class="me2">RegionGrowingRGB</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZRGB</span><span class="sy1">&gt;</span> clustering<span class="sy4">;</span>
	clustering.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
	clustering.<span class="me1">setSearchMethod</span><span class="br0">(</span>kdtree<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Here, the minimum cluster size affects also the postprocessing step:</span>
	<span class="co1">// clusters smaller than this will be merged with their neighbors.</span>
	clustering.<span class="me1">setMinClusterSize</span><span class="br0">(</span>100<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Set the distance threshold, to know which points will be considered neighbors.</span>
	clustering.<span class="me1">setDistanceThreshold</span><span class="br0">(</span>10<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Color threshold for comparing the RGB color of two points.</span>
	clustering.<span class="me1">setPointColorThreshold</span><span class="br0">(</span>6<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Region color threshold for the postprocessing step: clusters with colors</span>
	<span class="co1">// within the threshold will be merged in one.</span>
	clustering.<span class="me1">setRegionColorThreshold</span><span class="br0">(</span>5<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	std<span class="sy4">::</span><span class="me2">vector</span> <span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointIndices</span><span class="sy1">&gt;</span> clusters<span class="sy4">;</span>
	clustering.<span class="me1">extract</span><span class="br0">(</span>clusters<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// For every cluster...</span>
	<span class="kw4">int</span> currentClusterNum <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">(</span>std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointIndices</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_iterator</span> i <span class="sy1">=</span> clusters.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> i <span class="sy3">!</span><span class="sy1">=</span> clusters.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="co1">// ...add all its points to a new cloud...</span>
		pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZRGB</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cluster<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZRGB</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">(</span>std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_iterator</span> point <span class="sy1">=</span> i<span class="sy2">-</span><span class="sy1">&gt;</span>indices.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> point <span class="sy3">!</span><span class="sy1">=</span> i<span class="sy2">-</span><span class="sy1">&gt;</span>indices.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> point<span class="sy2">++</span><span class="br0">)</span>
			cluster<span class="sy2">-</span><span class="sy1">&gt;</span>points.<span class="me1">push_back</span><span class="br0">(</span>cloud<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span><span class="sy2">*</span>point<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
		cluster<span class="sy2">-</span><span class="sy1">&gt;</span>width <span class="sy1">=</span> cluster<span class="sy2">-</span><span class="sy1">&gt;</span>points.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
		cluster<span class="sy2">-</span><span class="sy1">&gt;</span>height <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
		cluster<span class="sy2">-</span><span class="sy1">&gt;</span>is_dense <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
&nbsp;
		<span class="co1">// ...and save it to disk.</span>
		<span class="kw1">if</span> <span class="br0">(</span>cluster<span class="sy2">-</span><span class="sy1">&gt;</span>points.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">&lt;=</span> 0<span class="br0">)</span>
			<span class="kw1">break</span><span class="sy4">;</span>
		std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"Cluster "</span> <span class="sy1">&lt;&lt;</span> currentClusterNum <span class="sy1">&lt;&lt;</span> <span class="st0">" has "</span> <span class="sy1">&lt;&lt;</span> cluster<span class="sy2">-</span><span class="sy1">&gt;</span>points.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">&lt;&lt;</span> <span class="st0">" points."</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
		std<span class="sy4">::</span><span class="me2">string</span> fileName <span class="sy1">=</span> <span class="st0">"cluster"</span> <span class="sy2">+</span> boost<span class="sy4">::</span><span class="me2">to_string</span><span class="br0">(</span>currentClusterNum<span class="br0">)</span> <span class="sy2">+</span> <span class="st0">".pcd"</span><span class="sy4">;</span>
		pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">savePCDFileASCII</span><span class="br0">(</span>fileName, <span class="sy2">*</span>cluster<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
		currentClusterNum<span class="sy2">++</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Minimum cluster size, Maximum cluster size, Search method, Distance threshold, Point color threshold, Region color threshold, [Indices]
</li>
<li> <b>Output</b>: Vector of Point indices (clusters)
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/region_growing_rgb_segmentation.php">Color-based region growing segmentation</a>
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_region_growing_r_g_b.html">pcl::RegionGrowingRGB</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_color_region_growing_clustering.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h2><span class="mw-headline" id="Min-Cut">Min-Cut</span></h2>
<p>The Min-Cut (minimum cut) algorithm is different from the previous ones. It performs binary segmentation: it divides the cloud in two clusters, one with points that do not belong to the object we are interested in (background points) and another with points that are considered part of the object (foreground points).
</p><p>In order to do that, the algorithm uses a vertex graph, where each vertex (node of the graph) represents a point, plus two additional vertices called <i>source</i> and <i>sink</i> that will be connected to the others with edges with different penalties (weights). Then, edges are also established between neighboring points, with a weight value each that depends on the distance that separates them. The greater the distance, the higher the probability of the edge being cut. The algorithm also needs as input a point that is known to be the center of the object, and the radius (size). After everything has been set, the minimum cut will be found, and we will have a list of foreground points.
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/segmentation/min_cut_segmentation.h&gt;</span>
&nbsp;
<span class="co2">#include &lt;iostream&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Object for storing the point cloud.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Min-cut clustering object.</span>
	pcl<span class="sy4">::</span><span class="me2">MinCutSegmentation</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> clustering<span class="sy4">;</span>
	clustering.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Create a cloud that lists all the points that we know belong to the object</span>
	<span class="co1">// (foreground points). We should set here the object's center.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> foregroundPoints<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointXYZ</span> point<span class="sy4">;</span>
	point.<span class="me1">x</span> <span class="sy1">=</span> <span class="nu16">100.0</span><span class="sy4">;</span>
	point.<span class="me1">y</span> <span class="sy1">=</span> <span class="nu16">100.0</span><span class="sy4">;</span>
	point.<span class="me1">z</span> <span class="sy1">=</span> <span class="nu16">100.0</span><span class="sy4">;</span>
	foregroundPoints<span class="sy2">-</span><span class="sy1">&gt;</span>points.<span class="me1">push_back</span><span class="br0">(</span>point<span class="br0">)</span><span class="sy4">;</span>
	clustering.<span class="me1">setForegroundPoints</span><span class="br0">(</span>foregroundPoints<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Set sigma, which affects the smooth cost calculation. It should be</span>
	<span class="co1">// set depending on the spacing between points in the cloud (resolution).</span>
	clustering.<span class="me1">setSigma</span><span class="br0">(</span>0.05<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Set the radius of the object we are looking for.</span>
	clustering.<span class="me1">setRadius</span><span class="br0">(</span>0.20<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Set the number of neighbors to look for. Increasing this also increases</span>
	<span class="co1">// the number of edges the graph will have.</span>
	clustering.<span class="me1">setNumberOfNeighbours</span><span class="br0">(</span>20<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Set the foreground penalty. It is the weight of the edges</span>
	<span class="co1">// that connect clouds points with the source vertex.</span>
	clustering.<span class="me1">setSourceWeight</span><span class="br0">(</span>0.6<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	std<span class="sy4">::</span><span class="me2">vector</span> <span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointIndices</span><span class="sy1">&gt;</span> clusters<span class="sy4">;</span>
	clustering.<span class="me1">extract</span><span class="br0">(</span>clusters<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"Maximum flow is "</span> <span class="sy1">&lt;&lt;</span> clustering.<span class="me1">getMaxFlow</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"."</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// For every cluster...</span>
	<span class="kw4">int</span> currentClusterNum <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">(</span>std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointIndices</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_iterator</span> i <span class="sy1">=</span> clusters.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> i <span class="sy3">!</span><span class="sy1">=</span> clusters.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="co1">// ...add all its points to a new cloud...</span>
		pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cluster<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">(</span>std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_iterator</span> point <span class="sy1">=</span> i<span class="sy2">-</span><span class="sy1">&gt;</span>indices.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> point <span class="sy3">!</span><span class="sy1">=</span> i<span class="sy2">-</span><span class="sy1">&gt;</span>indices.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> point<span class="sy2">++</span><span class="br0">)</span>
			cluster<span class="sy2">-</span><span class="sy1">&gt;</span>points.<span class="me1">push_back</span><span class="br0">(</span>cloud<span class="sy2">-</span><span class="sy1">&gt;</span>points<span class="br0">[</span><span class="sy2">*</span>point<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
		cluster<span class="sy2">-</span><span class="sy1">&gt;</span>width <span class="sy1">=</span> cluster<span class="sy2">-</span><span class="sy1">&gt;</span>points.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
		cluster<span class="sy2">-</span><span class="sy1">&gt;</span>height <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
		cluster<span class="sy2">-</span><span class="sy1">&gt;</span>is_dense <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
&nbsp;
		<span class="co1">// ...and save it to disk.</span>
		<span class="kw1">if</span> <span class="br0">(</span>cluster<span class="sy2">-</span><span class="sy1">&gt;</span>points.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">&lt;=</span> 0<span class="br0">)</span>
			<span class="kw1">break</span><span class="sy4">;</span>
		std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"Cluster "</span> <span class="sy1">&lt;&lt;</span> currentClusterNum <span class="sy1">&lt;&lt;</span> <span class="st0">" has "</span> <span class="sy1">&lt;&lt;</span> cluster<span class="sy2">-</span><span class="sy1">&gt;</span>points.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">&lt;&lt;</span> <span class="st0">" points."</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
		std<span class="sy4">::</span><span class="me2">string</span> fileName <span class="sy1">=</span> <span class="st0">"cluster"</span> <span class="sy2">+</span> boost<span class="sy4">::</span><span class="me2">to_string</span><span class="br0">(</span>currentClusterNum<span class="br0">)</span> <span class="sy2">+</span> <span class="st0">".pcd"</span><span class="sy4">;</span>
		pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">savePCDFileASCII</span><span class="br0">(</span>fileName, <span class="sy2">*</span>cluster<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
		currentClusterNum<span class="sy2">++</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>More details about the min-cut algorithm can be found in the <a rel="nofollow" class="external text" href="http://gfx.cs.princeton.edu/pubs/Golovinskiy_2009_MBS/paper_small.pdf">original paper (PDF)</a>.
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Foreground points (object's center), Object's radius, Sigma, Neighbor count, Foreground penalty, [Indices]
</li>
<li> <b>Output</b>: Vector of Point indices (object cluster)
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/min_cut_segmentation.php">Min-Cut Based Segmentation</a>
</li>
<li> <b>Publication</b>:
<ul>
<li> <a rel="nofollow" class="external text" href="http://gfx.cs.princeton.edu/pubs/Golovinskiy_2009_MBS/paper_small.pdf">Min-Cut Based Segmentation of Point Clouds</a> (Aleksey Golovinskiy and Thomas Funkhouser, 2009)
</li>
</ul>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_min_cut_clustering.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h2><span class="mw-headline" id="RANSAC">RANSAC</span></h2>
<p>As we saw in a previous section, PCL offers an implementation of the RANSAC algorithm to fit a set of points to a model. It will search the cloud and find a list of points that support the chosen model (plane, sphere...), and also compute the coefficients of the model. An object exists to perform easy segmentation of the points retrieved by the algorithm.
</p><p>If what you want is to extract the points of a model with already known coefficients, see this tutorial:
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/model_outlier_removal.php">Filtering a PointCloud using ModelOutlierRemoval</a>
</li>
</ul>
</div>
<p><br>
</p>
<h3><span class="mw-headline" id="Plane_model">Plane model</span></h3>
<p>The following code lets you segment all planar surfaces from a point cloud. This is very important, because you will be able to detect things like the floor, ceiling, walls, or a table in a scene. If you know that the object you are looking for is sitting on a table, you can discard all points that are not supported by it, with the associated performance gain. Take a look at the <a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_5:_3D_object_recognition_(pipeline)#Segmentation" title="PCL/OpenNI tutorial 5: 3D object recognition (pipeline)">pcl::ExtractPolygonalPrismData</a> class, which is designed for this. After giving the coefficients of the plane and computing the convex hull, you can then create a 3D prism by extruding the hull a given height, and extract all points that lie inside it.
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/sample_consensus/method_types.h&gt;</span>
<span class="co2">#include &lt;pcl/sample_consensus/model_types.h&gt;</span>
<span class="co2">#include &lt;pcl/segmentation/sac_segmentation.h&gt;</span>
&nbsp;
<span class="co2">#include &lt;iostream&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Objects for storing the point clouds.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> inlierPoints<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Object for storing the plane model coefficients.</span>
	pcl<span class="sy4">::</span><span class="me2">ModelCoefficients</span><span class="sy4">::</span><span class="me2">Ptr</span> coefficients<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">ModelCoefficients</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Create the segmentation object.</span>
	pcl<span class="sy4">::</span><span class="me2">SACSegmentation</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> segmentation<span class="sy4">;</span>
	segmentation.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Configure the object to look for a plane.</span>
	segmentation.<span class="me1">setModelType</span><span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">SACMODEL_PLANE</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Use RANSAC method.</span>
	segmentation.<span class="me1">setMethodType</span><span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">SAC_RANSAC</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Set the maximum allowed distance to the model.</span>
	segmentation.<span class="me1">setDistanceThreshold</span><span class="br0">(</span>0.01<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Enable model coefficient refinement (optional).</span>
	segmentation.<span class="me1">setOptimizeCoefficients</span><span class="br0">(</span><span class="kw2">true</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	pcl<span class="sy4">::</span><span class="me2">PointIndices</span> inlierIndices<span class="sy4">;</span>
	segmentation.<span class="me1">segment</span><span class="br0">(</span>inlierIndices, <span class="sy2">*</span>coefficients<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="kw1">if</span> <span class="br0">(</span>inlierIndices.<span class="me1">indices</span>.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">==</span> 0<span class="br0">)</span>
		std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"Could not find any points that fitted the plane model."</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
	<span class="kw1">else</span>
	<span class="br0">{</span>
		std<span class="sy4">::</span><span class="kw3">cerr</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"Model coefficients: "</span> <span class="sy1">&lt;&lt;</span> coefficients<span class="sy2">-</span><span class="sy1">&gt;</span>values<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy1">&lt;&lt;</span> <span class="st0">" "</span>
				  <span class="sy1">&lt;&lt;</span> coefficients<span class="sy2">-</span><span class="sy1">&gt;</span>values<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy1">&lt;&lt;</span> <span class="st0">" "</span>
				  <span class="sy1">&lt;&lt;</span> coefficients<span class="sy2">-</span><span class="sy1">&gt;</span>values<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy1">&lt;&lt;</span> <span class="st0">" "</span>
				  <span class="sy1">&lt;&lt;</span> coefficients<span class="sy2">-</span><span class="sy1">&gt;</span>values<span class="br0">[</span>3<span class="br0">]</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
&nbsp;
		<span class="co1">// Copy all inliers of the model to another cloud.</span>
		pcl<span class="sy4">::</span><span class="me2">copyPointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span><span class="sy2">*</span>cloud, inlierIndices, <span class="sy2">*</span>inlierPoints<span class="br0">)</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Model type, Method type, Model threshold, [Optimize coefficients]
</li>
<li> <b>Output</b>: Vector of Point indices (plane cluster)
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/planar_segmentation.php">Plane model segmentation</a>
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_s_a_c_segmentation.html">pcl::SACSegmentation</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_plane_segmentation.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h3><span class="mw-headline" id="Cylinder_model">Cylinder model</span></h3>
<p>Segmenting a cylinder shape out of the cloud if analogous. There is only an additional parameter for specifying the radii:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/sample_consensus/method_types.h&gt;</span>
<span class="co2">#include &lt;pcl/sample_consensus/model_types.h&gt;</span>
<span class="co2">#include &lt;pcl/segmentation/sac_segmentation.h&gt;</span>
&nbsp;
<span class="co2">#include &lt;iostream&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Objects for storing the point clouds.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> inlierPoints<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Object for storing the plane model coefficients.</span>
	pcl<span class="sy4">::</span><span class="me2">ModelCoefficients</span><span class="sy4">::</span><span class="me2">Ptr</span> coefficients<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">ModelCoefficients</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Create the segmentation object.</span>
	pcl<span class="sy4">::</span><span class="me2">SACSegmentation</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> segmentation<span class="sy4">;</span>
	segmentation.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Configure the object to look for a plane.</span>
	segmentation.<span class="me1">setModelType</span><span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">SACMODEL_CYLINDER</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Use RANSAC method.</span>
	segmentation.<span class="me1">setMethodType</span><span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">SAC_RANSAC</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Set the maximum allowed distance to the model.</span>
	segmentation.<span class="me1">setDistanceThreshold</span><span class="br0">(</span>0.01<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Enable model coefficient refinement (optional).</span>
	segmentation.<span class="me1">setOptimizeCoefficients</span><span class="br0">(</span><span class="kw2">true</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Set minimum and maximum radii of the cylinder.</span>
	segmentation.<span class="me1">setRadiusLimits</span><span class="br0">(</span>0, 0.1<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	pcl<span class="sy4">::</span><span class="me2">PointIndices</span> inlierIndices<span class="sy4">;</span>
	segmentation.<span class="me1">segment</span><span class="br0">(</span>inlierIndices, <span class="sy2">*</span>coefficients<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="kw1">if</span> <span class="br0">(</span>inlierIndices.<span class="me1">indices</span>.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">==</span> 0<span class="br0">)</span>
		std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"Could not find any points that fitted the cylinder model."</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
	<span class="co1">// Copy all inliers of the model to another cloud.</span>
	<span class="kw1">else</span> pcl<span class="sy4">::</span><span class="me2">copyPointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span><span class="sy2">*</span>cloud, inlierIndices, <span class="sy2">*</span>inlierPoints<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Model type, Method type, Model threshold, [Optimize coefficients]
</li>
<li> <b>Output</b>: Vector of Point indices (cylinder cluster)
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/cylinder_segmentation.php">Cylinder model segmentation</a>
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_s_a_c_segmentation.html">pcl::SACSegmentation</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_cylinder_segmentation.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h1><span class="mw-headline" id="Retrieving_the_hull">Retrieving the hull</span></h1>
<p>For a given set of points, PCL can compute the external hull of the shape, using the <a rel="nofollow" class="external text" href="http://www.qhull.org/">QHull library</a>. The hull could be defined as the points that conform the outermost boundary of the set, like a shell showing the volume. There are two types of hull that you can calculate, the <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Convex_hull">convex</a> and the concave one. A convex hull can not have "holes", that is, the segment that connects any pair of points can never cross "empty" space (not inside the hull). A concave hull, on the other hand, usually takes less area, like you can see in the following images:
</p><p><br>
</p>
<center><ul class="gallery mw-gallery-traditional">
		<li class="gallerybox" style="width: 335px"><div style="width: 335px">
			<div class="thumb" style="width: 330px;"><div style="margin:15px auto;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:ConcaveHull.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 3_ Cloud processing (advanced) - Robótica - ULE_files/ConcaveHull.png" width="127" height="120"></a></div></div>
			<div class="gallerytext">
<p>Concave hull.
</p>
			</div>
		</div></li>
		<li class="gallerybox" style="width: 335px"><div style="width: 335px">
			<div class="thumb" style="width: 330px;"><div style="margin:15px auto;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:ConvexHull.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 3_ Cloud processing (advanced) - Robótica - ULE_files/ConvexHull.png" width="127" height="120"></a></div></div>
			<div class="gallerytext">
<p>Convex hull.
</p>
			</div>
		</div></li>
</ul></center>
<p><br>
</p>
<h2><span class="mw-headline" id="Concave_hull">Concave hull</span></h2>
<p>The following code shows how you can use PCL to compute the concave hull of the first plane found in the scene:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/sample_consensus/method_types.h&gt;</span>
<span class="co2">#include &lt;pcl/sample_consensus/model_types.h&gt;</span>
<span class="co2">#include &lt;pcl/segmentation/sac_segmentation.h&gt;</span>
<span class="co2">#include &lt;pcl/filters/extract_indices.h&gt;</span>
<span class="co2">#include &lt;pcl/surface/concave_hull.h&gt;</span>
<span class="co2">#include &lt;pcl/visualization/cloud_viewer.h&gt;</span>
&nbsp;
<span class="co2">#include &lt;iostream&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Objects for storing the point clouds.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> plane<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> concaveHull<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Get the plane model, if present.</span>
	pcl<span class="sy4">::</span><span class="me2">ModelCoefficients</span><span class="sy4">::</span><span class="me2">Ptr</span> coefficients<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">ModelCoefficients</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">SACSegmentation</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> segmentation<span class="sy4">;</span>
	segmentation.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
	segmentation.<span class="me1">setModelType</span><span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">SACMODEL_PLANE</span><span class="br0">)</span><span class="sy4">;</span>
	segmentation.<span class="me1">setMethodType</span><span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">SAC_RANSAC</span><span class="br0">)</span><span class="sy4">;</span>
	segmentation.<span class="me1">setDistanceThreshold</span><span class="br0">(</span>0.01<span class="br0">)</span><span class="sy4">;</span>
	segmentation.<span class="me1">setOptimizeCoefficients</span><span class="br0">(</span><span class="kw2">true</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointIndices</span><span class="sy4">::</span><span class="me2">Ptr</span> inlierIndices<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointIndices</span><span class="br0">)</span><span class="sy4">;</span>
	segmentation.<span class="me1">segment</span><span class="br0">(</span><span class="sy2">*</span>inlierIndices, <span class="sy2">*</span>coefficients<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="kw1">if</span> <span class="br0">(</span>inlierIndices<span class="sy2">-</span><span class="sy1">&gt;</span>indices.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">==</span> 0<span class="br0">)</span>
		std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"Could not find a plane in the scene."</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
	<span class="kw1">else</span>
	<span class="br0">{</span>
		<span class="co1">// Copy the points of the plane to a new cloud.</span>
		pcl<span class="sy4">::</span><span class="me2">ExtractIndices</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> extract<span class="sy4">;</span>
		extract.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
		extract.<span class="me1">setIndices</span><span class="br0">(</span>inlierIndices<span class="br0">)</span><span class="sy4">;</span>
		extract.<span class="me1">filter</span><span class="br0">(</span><span class="sy2">*</span>plane<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
		<span class="co1">// Object for retrieving the concave hull.</span>
		pcl<span class="sy4">::</span><span class="me2">ConcaveHull</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> hull<span class="sy4">;</span>
		hull.<span class="me1">setInputCloud</span><span class="br0">(</span>plane<span class="br0">)</span><span class="sy4">;</span>
		<span class="co1">// Set alpha, which is the maximum length from a vertex to the center of the voronoi cell</span>
		<span class="co1">// (the smaller, the greater the resolution of the hull).</span>
		hull.<span class="me1">setAlpha</span><span class="br0">(</span>0.1<span class="br0">)</span><span class="sy4">;</span>
		hull.<span class="me1">reconstruct</span><span class="br0">(</span><span class="sy2">*</span>concaveHull<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
		<span class="co1">// Visualize the hull.</span>
		pcl<span class="sy4">::</span><span class="me2">visualization</span><span class="sy4">::</span><span class="me2">CloudViewer</span> viewerPlane<span class="br0">(</span><span class="st0">"Concave hull"</span><span class="br0">)</span><span class="sy4">;</span>
		viewerPlane.<span class="me1">showCloud</span><span class="br0">(</span>concaveHull<span class="br0">)</span><span class="sy4">;</span>
		<span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span>viewerPlane.<span class="me1">wasStopped</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
		<span class="br0">{</span>
			<span class="co1">// Do nothing but wait.</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>By choosing a smaller alpha value, you can improve the detail of the hull.
</p><p><br>
</p>
<center><ul class="gallery mw-gallery-traditional">
		<li class="gallerybox" style="width: 335px"><div style="width: 335px">
			<div class="thumb" style="width: 330px;"><div style="margin:15px auto;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:ConcaveHullBefore.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 3_ Cloud processing (advanced) - Robótica - ULE_files/ConcaveHullBefore.png" width="214" height="120"></a></div></div>
			<div class="gallerytext">
<p>Table scene taken from the PCL dataset.
</p>
			</div>
		</div></li>
		<li class="gallerybox" style="width: 335px"><div style="width: 335px">
			<div class="thumb" style="width: 330px;"><div style="margin:15px auto;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:ConcaveHullAfter.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 3_ Cloud processing (advanced) - Robótica - ULE_files/ConcaveHullAfter.png" width="213" height="120"></a></div></div>
			<div class="gallerytext">
<p>Concave hull of the table seen in the cloud (better seen fullscreen).
</p>
			</div>
		</div></li>
</ul></center>
<p><br>
The class <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_crop_hull.html">pcl::CropHull</a> lets you find points that lie inside or outside a hull. One possible use, for a scene with a table and objects on it, would be:
</p>
<ol>
<li> Find a plane in the scene (it should be the table).
</li>
<li> Compute the hull of the plane.
</li>
<li> Project the points of the cloud onto the plane.
</li>
<li> Find which projected points are lying inside the plane hull. Those belong to objects sitting on the table.
</li>
</ol>
<p><br>
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Alpha
</li>
<li> <b>Output</b>: Hull points (concave)
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/hull_2d.php">Construct a concave or convex hull polygon for a plane model</a>
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_concave_hull.html">pcl::ConcaveHull</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_concave_hull.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h2><span class="mw-headline" id="Convex_hull">Convex hull</span></h2>
<p>Computing the convex hull is done the same way, just changing the names accordingly. Also, there is no need to set the alpha parameter here:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/sample_consensus/method_types.h&gt;</span>
<span class="co2">#include &lt;pcl/sample_consensus/model_types.h&gt;</span>
<span class="co2">#include &lt;pcl/segmentation/sac_segmentation.h&gt;</span>
<span class="co2">#include &lt;pcl/filters/extract_indices.h&gt;</span>
<span class="co2">#include &lt;pcl/surface/convex_hull.h&gt;</span>
<span class="co2">#include &lt;pcl/visualization/cloud_viewer.h&gt;</span>
&nbsp;
<span class="co2">#include &lt;iostream&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Objects for storing the point clouds.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> plane<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> convexHull<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Get the plane model, if present.</span>
	pcl<span class="sy4">::</span><span class="me2">ModelCoefficients</span><span class="sy4">::</span><span class="me2">Ptr</span> coefficients<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">ModelCoefficients</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">SACSegmentation</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> segmentation<span class="sy4">;</span>
	segmentation.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
	segmentation.<span class="me1">setModelType</span><span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">SACMODEL_PLANE</span><span class="br0">)</span><span class="sy4">;</span>
	segmentation.<span class="me1">setMethodType</span><span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">SAC_RANSAC</span><span class="br0">)</span><span class="sy4">;</span>
	segmentation.<span class="me1">setDistanceThreshold</span><span class="br0">(</span>0.01<span class="br0">)</span><span class="sy4">;</span>
	segmentation.<span class="me1">setOptimizeCoefficients</span><span class="br0">(</span><span class="kw2">true</span><span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">PointIndices</span><span class="sy4">::</span><span class="me2">Ptr</span> inlierIndices<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointIndices</span><span class="br0">)</span><span class="sy4">;</span>
	segmentation.<span class="me1">segment</span><span class="br0">(</span><span class="sy2">*</span>inlierIndices, <span class="sy2">*</span>coefficients<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="kw1">if</span> <span class="br0">(</span>inlierIndices<span class="sy2">-</span><span class="sy1">&gt;</span>indices.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">==</span> 0<span class="br0">)</span>
		std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"Could not find a plane in the scene."</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
	<span class="kw1">else</span>
	<span class="br0">{</span>
		<span class="co1">// Copy the points of the plane to a new cloud.</span>
		pcl<span class="sy4">::</span><span class="me2">ExtractIndices</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> extract<span class="sy4">;</span>
		extract.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
		extract.<span class="me1">setIndices</span><span class="br0">(</span>inlierIndices<span class="br0">)</span><span class="sy4">;</span>
		extract.<span class="me1">filter</span><span class="br0">(</span><span class="sy2">*</span>plane<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
		<span class="co1">// Object for retrieving the convex hull.</span>
		pcl<span class="sy4">::</span><span class="me2">ConvexHull</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span> hull<span class="sy4">;</span>
		hull.<span class="me1">setInputCloud</span><span class="br0">(</span>plane<span class="br0">)</span><span class="sy4">;</span>
		hull.<span class="me1">reconstruct</span><span class="br0">(</span><span class="sy2">*</span>convexHull<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
		<span class="co1">// Visualize the hull.</span>
		pcl<span class="sy4">::</span><span class="me2">visualization</span><span class="sy4">::</span><span class="me2">CloudViewer</span> viewerPlane<span class="br0">(</span><span class="st0">"Convex hull"</span><span class="br0">)</span><span class="sy4">;</span>
		viewerPlane.<span class="me1">showCloud</span><span class="br0">(</span>convexHull<span class="br0">)</span><span class="sy4">;</span>
		<span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span>viewerPlane.<span class="me1">wasStopped</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
		<span class="br0">{</span>
			<span class="co1">// Do nothing but wait.</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points
</li>
<li> <b>Output</b>: Hull points (convex)
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/hull_2d.php">Construct a concave or convex hull polygon for a plane model</a>
</li>
<li> <b>API</b>: <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_convex_hull.html">pcl::ConvexHull</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_convex_hull.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<h1><span class="mw-headline" id="Reconstruction">Reconstruction</span></h1>
<p>To learn about how to use PCL to build a smooth, parametric surface representation from a point cloud, you can read the following:
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/bspline_fitting.php">Fitting trimmed B-splines to unordered point clouds</a>
</li>
</ul>
</div>
<p><br>
</p>
<h2><span class="mw-headline" id="Triangulation">Triangulation</span></h2>
<p>Triangulation is a a way of estimating the surface captured by a point cloud, by connecting points with each other, ending up with a continous polygon mesh (three-sided polygons, that is, triangles). After you retrieve this surface mesh, you can for example export it to a format that most 3D modelling tools will understand, like <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/VTK">VTK (Visualization Toolkit)</a>, which can be opened in Blender or 3ds Max. PCL can also convert from VTK to <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/PLY_%28file_format%29">PLY</a> or <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Wavefront_.obj_file">OBJ</a>.
</p><p>The following code uses PCL's implementation of a greedy triangulation algorithm that works with local 2D projections. For every point, it looks "down" along the normal, and connects neighboring points. For more information, specially regarding the parameters, check the API or the original PCL tutorial:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="cpp source-cpp" style="font-family:monospace;"><pre class="de1"><span class="co2">#include &lt;pcl/io/pcd_io.h&gt;</span>
<span class="co2">#include &lt;pcl/features/normal_3d.h&gt;</span>
<span class="co2">#include &lt;pcl/surface/gp3.h&gt;</span>
<span class="co2">#include &lt;pcl/io/vtk_io.h&gt;</span>
&nbsp;
<span class="kw4">int</span>
main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span><span class="sy2">**</span> argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="co1">// Object for storing the point cloud.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloud<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Object for storing the normals.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">Normal</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> normals<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">Normal</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Object for storing both the points and the normals.</span>
	pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointNormal</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> cloudNormals<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">PointCloud</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointNormal</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Read a PCD file from disk.</span>
	<span class="kw1">if</span> <span class="br0">(</span>pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">loadPCDFile</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">(</span>argv<span class="br0">[</span>1<span class="br0">]</span>, <span class="sy2">*</span>cloud<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> 0<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="co1">// Normal estimation.</span>
	pcl<span class="sy4">::</span><span class="me2">NormalEstimation</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span>, pcl<span class="sy4">::</span><span class="me2">Normal</span><span class="sy1">&gt;</span> normalEstimation<span class="sy4">;</span>
	normalEstimation.<span class="me1">setInputCloud</span><span class="br0">(</span>cloud<span class="br0">)</span><span class="sy4">;</span>
	normalEstimation.<span class="me1">setRadiusSearch</span><span class="br0">(</span>0.03<span class="br0">)</span><span class="sy4">;</span>
	pcl<span class="sy4">::</span><span class="me2">search</span><span class="sy4">::</span><span class="me2">KdTree</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> kdtree<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">search</span><span class="sy4">::</span><span class="me2">KdTree</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointXYZ</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	normalEstimation.<span class="me1">setSearchMethod</span><span class="br0">(</span>kdtree<span class="br0">)</span><span class="sy4">;</span>
	normalEstimation.<span class="me1">compute</span><span class="br0">(</span><span class="sy2">*</span>normals<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// The triangulation object requires the points and normals to be stored in the same structure.</span>
	pcl<span class="sy4">::</span><span class="me2">concatenateFields</span><span class="br0">(</span><span class="sy2">*</span>cloud, <span class="sy2">*</span>normals, <span class="sy2">*</span>cloudNormals<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Tree object for searches in this new object.</span>
	pcl<span class="sy4">::</span><span class="me2">search</span><span class="sy4">::</span><span class="me2">KdTree</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointNormal</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">Ptr</span> kdtree2<span class="br0">(</span><span class="kw3">new</span> pcl<span class="sy4">::</span><span class="me2">search</span><span class="sy4">::</span><span class="me2">KdTree</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointNormal</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
	kdtree2<span class="sy2">-</span><span class="sy1">&gt;</span>setInputCloud<span class="br0">(</span>cloudNormals<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Triangulation object.</span>
	pcl<span class="sy4">::</span><span class="me2">GreedyProjectionTriangulation</span><span class="sy1">&lt;</span>pcl<span class="sy4">::</span><span class="me2">PointNormal</span><span class="sy1">&gt;</span> triangulation<span class="sy4">;</span>
	<span class="co1">// Output object, containing the mesh.</span>
	pcl<span class="sy4">::</span><span class="me2">PolygonMesh</span> triangles<span class="sy4">;</span>
	<span class="co1">// Maximum distance between connected points (maximum edge length).</span>
	triangulation.<span class="me1">setSearchRadius</span><span class="br0">(</span>0.025<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Maximum acceptable distance for a point to be considered,</span>
	<span class="co1">// relative to the distance of the nearest point.</span>
	triangulation.<span class="me1">setMu</span><span class="br0">(</span>2.5<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// How many neighbors are searched for.</span>
	triangulation.<span class="me1">setMaximumNearestNeighbors</span><span class="br0">(</span>100<span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Points will not be connected to the current point</span>
	<span class="co1">// if their normals deviate more than the specified angle.</span>
	triangulation.<span class="me1">setMaximumSurfaceAngle</span><span class="br0">(</span>M_PI <span class="sy2">/</span> 4<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 45 degrees.</span>
	<span class="co1">// If false, the direction of normals will not be taken into account</span>
	<span class="co1">// when computing the angle between them.</span>
	triangulation.<span class="me1">setNormalConsistency</span><span class="br0">(</span><span class="kw2">false</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// Minimum and maximum angle there can be in a triangle.</span>
	<span class="co1">// The first is not guaranteed, the second is.</span>
	triangulation.<span class="me1">setMinimumAngle</span><span class="br0">(</span>M_PI <span class="sy2">/</span> 18<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 10 degrees.</span>
	triangulation.<span class="me1">setMaximumAngle</span><span class="br0">(</span>2 <span class="sy2">*</span> M_PI <span class="sy2">/</span> 3<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 120 degrees.</span>
&nbsp;
	<span class="co1">// Triangulate the cloud.</span>
	triangulation.<span class="me1">setInputCloud</span><span class="br0">(</span>cloudNormals<span class="br0">)</span><span class="sy4">;</span>
	triangulation.<span class="me1">setSearchMethod</span><span class="br0">(</span>kdtree2<span class="br0">)</span><span class="sy4">;</span>
	triangulation.<span class="me1">reconstruct</span><span class="br0">(</span>triangles<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// Save to disk.</span>
	pcl<span class="sy4">::</span><span class="me2">io</span><span class="sy4">::</span><span class="me2">saveVTKFile</span><span class="br0">(</span><span class="st0">"mesh.vtk"</span>, triangles<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p><br>
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:602px;"><a href="http://robotica.unileon.es/mediawiki/index.php/File:VTK.png" class="image"><img alt="" src="./PCL_OpenNI tutorial 3_ Cloud processing (advanced) - Robótica - ULE_files/VTK.png" width="600" height="375" class="thumbimage"></a>  <div class="thumbcaption"><div class="magnify"><a href="http://robotica.unileon.es/mediawiki/index.php/File:VTK.png" class="internal" title="Enlarge"><img src="./PCL_OpenNI tutorial 3_ Cloud processing (advanced) - Robótica - ULE_files/magnify-clip.png" width="15" height="11" alt=""></a></div>VTK file produced by triangulation of a point cloud.</div></div></div></div>
<p><br>
</p>
<div style="background-color: #F8F8F8; border-style: dotted;">
<ul>
<li> <b>Input</b>: Points, Search method, Maximum distance, Maximum edge length, Minimum angle, Maximum angle, Maximum surface angle, [Normal consistency]
</li>
<li> <b>Output</b>: Polygon mesh
</li>
<li> <b>Tutorial</b>: <a rel="nofollow" class="external text" href="http://pointclouds.org/documentation/tutorials/greedy_projection.php">Fast triangulation of unordered point clouds</a>
</li>
<li> <b>API</b>:
<ul>
<li> <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/classpcl_1_1_greedy_projection_triangulation.html">pcl::GreedyProjectionTriangulation</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://docs.pointclouds.org/trunk/structpcl_1_1_polygon_mesh.html">pcl::PolygonMesh</a>
</li>
</ul>
</li>
<li> <a rel="nofollow" class="external text" href="http://robotica.unileon.es/~victorm/PCL_triangulation.tar.gz">Download</a>
</li>
</ul>
</div>
<p><br>
</p>
<hr>
<hr>
<p>Go to root: <a href="http://robotica.unileon.es/mediawiki/index.php/PhD-3D-Object-Tracking" title="PhD-3D-Object-Tracking">PhD-3D-Object-Tracking</a>
</p><p>Links to articles:
</p><p><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_0:_The_very_basics" title="PCL/OpenNI tutorial 0: The very basics">PCL/OpenNI tutorial 0: The very basics</a>
</p><p><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_1:_Installing_and_testing" title="PCL/OpenNI tutorial 1: Installing and testing">PCL/OpenNI tutorial 1: Installing and testing</a>
</p><p><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_2:_Cloud_processing_(basic)" title="PCL/OpenNI tutorial 2: Cloud processing (basic)">PCL/OpenNI tutorial 2: Cloud processing (basic)</a>
</p><p><strong class="selflink">PCL/OpenNI tutorial 3: Cloud processing (advanced)</strong>
</p><p><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_4:_3D_object_recognition_(descriptors)" title="PCL/OpenNI tutorial 4: 3D object recognition (descriptors)">PCL/OpenNI tutorial 4: 3D object recognition (descriptors)</a>
</p><p><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_5:_3D_object_recognition_(pipeline)" title="PCL/OpenNI tutorial 5: 3D object recognition (pipeline)">PCL/OpenNI tutorial 5: 3D object recognition (pipeline)</a>
</p><p><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_troubleshooting" title="PCL/OpenNI troubleshooting">PCL/OpenNI troubleshooting</a>
</p>
<!-- 
NewPP limit report
CPU time usage: 0.491 seconds
Real time usage: 0.503 seconds
Preprocessor visited node count: 275/1000000
Preprocessor generated node count: 558/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:292-0!*!0!!en!2!* and timestamp 20150622123130
 -->
</div>								<div class="printfooter">
				Retrieved from "<a href="http://robotica.unileon.es/mediawiki/index.php?title=PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)&oldid=4684">http://robotica.unileon.es/mediawiki/index.php?title=PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)&amp;oldid=4684</a>"				</div>
												<div id="catlinks" class="catlinks catlinks-allhidden"></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
				<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
	<h3 id="p-personal-label">Personal tools</h3>
	<ul>
<li id="pt-login"><a href="http://robotica.unileon.es/mediawiki/index.php?title=Special:UserLogin&returnto=PCL%2FOpenNI+tutorial+3%3A+Cloud+processing+%28advanced%29" title="You are encouraged to log in; however, it is not mandatory [alt-shift-o]" accesskey="o">Log in</a></li>	</ul>
</div>
				<div id="left-navigation">
					<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
	<h3 id="p-namespaces-label">Namespaces</h3>
	<ul>
					<li id="ca-nstab-main" class="selected"><span><a href="./PCL_OpenNI tutorial 3_ Cloud processing (advanced) - Robótica - ULE_files/PCL_OpenNI tutorial 3_ Cloud processing (advanced) - Robótica - ULE.html" title="View the content page [alt-shift-c]" accesskey="c">Page</a></span></li>
					<li id="ca-talk" class="new"><span><a href="http://robotica.unileon.es/mediawiki/index.php?title=Talk:PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)&action=edit&redlink=1" title="Discussion about the content page [alt-shift-t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>
<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
	<h3 id="mw-vector-current-variant">
		</h3>
	<h3 id="p-variants-label" tabindex="0"><span>Variants</span><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#" tabindex="-1"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
				</div>
				<div id="right-navigation">
					<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
	<h3 id="p-views-label">Views</h3>
	<ul>
					<li id="ca-view" class="selected"><span><a href="./PCL_OpenNI tutorial 3_ Cloud processing (advanced) - Robótica - ULE_files/PCL_OpenNI tutorial 3_ Cloud processing (advanced) - Robótica - ULE.html">Read</a></span></li>
					<li id="ca-viewsource"><span><a href="http://robotica.unileon.es/mediawiki/index.php?title=PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)&action=edit" title="This page is protected.
You can view its source [alt-shift-e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="http://robotica.unileon.es/mediawiki/index.php?title=PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)&action=history" title="Past revisions of this page [alt-shift-h]" accesskey="h">View history</a></span></li>
			</ul>
</div>
<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
	<h3 id="p-cactions-label" tabindex="0"><span>Actions</span><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#" tabindex="-1"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
<div id="p-search" role="search">
	<h3><label for="searchInput">Search</label></h3>
	<form action="http://robotica.unileon.es/mediawiki/index.php" id="searchform">
				<div id="simpleSearch">
						<input name="search" placeholder="Search" title="Search Robótica - ULE [alt-shift-f]" accesskey="f" id="searchInput" tabindex="1" autocomplete="off">						<button type="submit" name="button" title="Search the pages for this text" id="searchButton"><img src="./PCL_OpenNI tutorial 3_ Cloud processing (advanced) - Robótica - ULE_files/search-ltr.png" alt="Search" width="12" height="13"></button>								<input type="hidden" name="title" value="Special:Search">
		</div>
	</form>
</div>
				</div>
			</div>
			<div id="mw-panel" class="collapsible-nav">
					<div id="p-logo" role="banner"><a style="background-image: url(/mediawiki/skins/common/images/LogoRobotica_small.png);" href="http://robotica.unileon.es/mediawiki/index.php/Home" title="Visit the main page"></a></div>
				<div class="portal first persistent" role="navigation" id="p-Contents" aria-labelledby="p-Contents-label">
	<h3 id="p-Contents-label">Contents</h3>
	<div class="body">
		<ul>
			<li id="n-Home"><a href="http://robotica.unileon.es/mediawiki/index.php/Home">Home</a></li>
			<li id="n-People"><a href="http://robotica.unileon.es/mediawiki/index.php/People">People</a></li>
			<li id="n-Publications"><a href="http://robotica.unileon.es/mediawiki/index.php/Publications">Publications</a></li>
			<li id="n-Activities"><a href="http://robotica.unileon.es/mediawiki/index.php/Activities">Activities</a></li>
			<li id="n-Projects"><a href="http://robotica.unileon.es/mediawiki/index.php/Projects">Projects</a></li>
			<li id="n-Software"><a href="http://robotica.unileon.es/mediawiki/index.php/Software">Software</a></li>
		</ul>
	</div>
</div>
<div class="portal expanded" role="navigation" id="p-Wiki" aria-labelledby="p-Wiki-label">
	<h3 id="p-Wiki-label" tabindex="2"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#">Wiki</a></h3>
	<div class="body" style="display: block;">
		<ul>
			<li id="n-recentchanges"><a href="http://robotica.unileon.es/mediawiki/index.php/Special:RecentChanges" title="A list of recent changes in the wiki [alt-shift-r]" accesskey="r">Recent changes</a></li>
			<li id="n-randompage"><a href="http://robotica.unileon.es/mediawiki/index.php/Special:Random" title="Load a random page [alt-shift-x]" accesskey="x">Random page</a></li>
			<li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" rel="nofollow" title="The place to find out">Help</a></li>
		</ul>
	</div>
</div>
<div class="portal collapsed" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
	<h3 id="p-tb-label" tabindex="3"><a href="http://robotica.unileon.es/mediawiki/index.php/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)#">Tools</a></h3>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="http://robotica.unileon.es/mediawiki/index.php/Special:WhatLinksHere/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)" title="A list of all wiki pages that link here [alt-shift-j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="http://robotica.unileon.es/mediawiki/index.php/Special:RecentChangesLinked/PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)" title="Recent changes in pages linked from this page [alt-shift-k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="http://robotica.unileon.es/mediawiki/index.php/Special:SpecialPages" title="A list of all special pages [alt-shift-q]" accesskey="q">Special pages</a></li>
			<li id="t-print"><a href="http://robotica.unileon.es/mediawiki/index.php?title=PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)&printable=yes" rel="alternate" title="Printable version of this page [alt-shift-p]" accesskey="p">Printable version</a></li>
			<li id="t-permalink"><a href="http://robotica.unileon.es/mediawiki/index.php?title=PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)&oldid=4684" title="Permanent link to this revision of the page">Permanent link</a></li>
			<li id="t-info"><a href="http://robotica.unileon.es/mediawiki/index.php?title=PCL/OpenNI_tutorial_3:_Cloud_processing_(advanced)&action=info">Page information</a></li>
		</ul>
	</div>
</div>
			</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 6 April 2015, at 17:29.</li>
											<li id="footer-info-viewcount">This page has been accessed 16,538 times.</li>
									</ul>
									<div style="clear:both"></div>
		</div>
		<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","skins.vector.collapsibleNav"],null,true);
}</script>
<script>if(window.mw){
mw.loader.state({"site":"ready"});
}</script>
<!-- Served in 0.079 secs. -->
	

<div class="suggestions" style="display: none; font-size: 13px;"><div class="suggestions-results"></div><div class="suggestions-special"></div></div></body></html>